{"meta":{"title":"Dragon Liu","subtitle":null,"description":null,"author":"Dragon Liu","url":"https://dragonliu2021.github.io","root":"/"},"pages":[{"title":"看板","date":"2022-07-04T13:27:16.402Z","updated":"2022-07-04T13:27:16.402Z","comments":false,"path":"about/index.html","permalink":"https://dragonliu2021.github.io/about/index.html","excerpt":"","text":"联系方式：dragonliu2018@gmail.com 1 分类 具体见数据结构和算法.xmind 目录名称 标签 01-基本 模拟 02-数据结构 STL、数组、链表、栈、队列、哈希表、位图、并查集、优先队列\\堆、单调队列\\栈 03-排序 直接插入排序、希尔排序、冒泡排序、快速排序、简单选择排序、堆排序、归并排序、基数排序 04-查找 线性表查找、树结构查找、散列表查找 05-搜索 DFS、BFS、回溯法、二分 06-字符串 KMP、后缀数组、AC自动机、字典树 07-树 二叉树、多路查找树、堆、树状数组、线段树、字典树 08-图论 图的存储、最短路径、最小生成树、拓扑排序、关键路径、二分图、网络流 09-算法 贪心算法、分治算法、动态规划、背包、回溯算法、随机化算法、递归算法 10-数学 组合数学、数论、矩阵运算、概率分析、博弈论、位运算 11-技巧 前缀和、差分、双指针、打表 12-未分类 - 面试相关 面试"},{"title":"分类","date":"2022-01-20T08:24:01.513Z","updated":"2022-01-20T06:59:05.762Z","comments":false,"path":"categories/index.html","permalink":"https://dragonliu2021.github.io/categories/index.html","excerpt":"","text":""},{"title":"光影流年","date":"2019-09-13T08:56:36.000Z","updated":"2021-02-26T09:56:36.000Z","comments":true,"path":"gallery/index.html","permalink":"https://dragonliu2021.github.io/gallery/index.html","excerpt":"","text":"12"},{"title":"友情链接","date":"2019-09-13T08:58:45.000Z","updated":"2021-02-23T13:00:44.000Z","comments":true,"path":"link/index.html","permalink":"https://dragonliu2021.github.io/link/index.html","excerpt":"","text":""},{"title":"那些年，听过的音乐","date":"2022-01-24T13:08:47.234Z","updated":"2022-01-24T13:08:47.234Z","comments":true,"path":"music/index.html","permalink":"https://dragonliu2021.github.io/music/index.html","excerpt":"","text":"123&#123;% meting &quot;7429975963&quot; &quot;tencent&quot; &quot;playlist&quot; %&#125;&#123;% douban music 30121600 %&#125;"},{"title":"Repositories","date":"2022-01-20T06:59:05.762Z","updated":"2022-01-20T06:59:05.762Z","comments":false,"path":"repository/index.html","permalink":"https://dragonliu2021.github.io/repository/index.html","excerpt":"","text":""},{"title":"主题更新日志","date":"2019-09-13T08:58:45.000Z","updated":"2021-02-26T13:34:46.000Z","comments":true,"path":"theme/index.html","permalink":"https://dragonliu2021.github.io/theme/index.html","excerpt":"","text":"本站当前主题使用的是Hexo Butterfly TODO 博客相册页面 2021 年 02 月 2月23日： 添加菜单-主题 更改首页图片：点击查看 2月26日 解决博客加密文章本地测试通过，提交到GitHub后未通过问题，访问 https://dragonliu.tk 即可。参考：hexo-blog-encrypt 在 http 环境下无法使用的原因分析 文章加密部分使用 sweetalert 来美化错误提示。参考"},{"title":"标签","date":"2022-01-20T06:59:05.763Z","updated":"2022-01-20T06:59:05.763Z","comments":false,"path":"tags/index.html","permalink":"https://dragonliu2021.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构+算法复习","slug":"数据结构复习","date":"2022-04-19T05:44:43.000Z","updated":"2022-04-19T05:46:43.041Z","comments":true,"path":"2022/04/19/数据结构复习/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/数据结构复习/","excerpt":"","text":"南航教材：《数据结构（C语言版）》严蔚敏、吴伟民 编著 南大教材：《数据结构》（用面向对象方法与C++语言描述），第2版 ，殷人昆主编 1 分治算法、动态规划、回溯法、分支定界法、贪心算法 分治算法：将一个大问题，分割成一些规模较小的子问题，这些子问题相互独立且与原问题性质相同，求出子问题的解，就可得到原问题的解。 动态规划：将一个大问题，分割成一些规模较小的子问题，求出子问题的解，就可得到原问题的解。与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的。为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在数组中。 回溯法：在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果不包含，则逐层向其祖先结点回溯。 分支限界法：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。分支限界法常以广度优先或以最小耗费优先的方式搜索问题的解空间树。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。 贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 2 快速排序的思想、优化方法 快速排序的基本思想：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 快速排序的三个步骤： 选择枢纽元：在待排序列中，按照某种方式挑出一个元素，作为 “枢纽元”（pivot） 分割操作：以该枢纽元在序列中的实际位置，把序列分成两个子序列。此时，在枢纽元左边的元素都比该枢纽元小，在枢纽元右边的元素都比枢纽元大 递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 优化方法 当待排序序列的长度分割到比较小的长度后，使用插入排序。 在每一次分割结束后，可以把与划分元相等的元素聚在一起，继续下次分割时，不用再对与划分元相等元素分割。 最佳划分是将序列划分成等长的两个子序列，因此提出三数取中的思想。取序列中，下标第一位，下标中间一位，下标最后一位的三个数进行排序，取排序结果中排中间的数据作为划分元。 快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。 3 各种排序算法的最好、平均、最坏时间复杂度 4 Trie 树 Trie 树，又称单词查找树、字典树，是一种树形结构，是一种哈希树的变种，是一种用于快速检索的多叉树结构。 典型应用：用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 核心思想：空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 对于搜索引擎，一般会保留一个单词查找树的前N个字（全球或最近热门使用的）； 对于每个用户，保持Trie树最近前N个字为该用户使用的结果。 如果用户点击任何搜索结果，Trie树可以非常迅速并异步获取完整的部分／模糊查找，然后预取数据，再用一个Web应用程序可以发送一个较小的一组结果的浏览器。 5 P/NP问题 P问题：即为所有可以由一个确定型图灵机在多项式表达的时间内解决的问题；（矩阵乘法、多项式求值） NP问题（Nondeterminism Polynomial）：由所有可以在多项式时间内验证它的解是否正确的决定问题组成。（典型的子集求和问题，大数分解问题） NP-hard问题：任意np问题都可以在多项式时间内归约为该问题。归约的意思是为了解决问题A，先将问题A归约为另一个问题B，解决问题B同时也间接解决了问题A。 NP完全问题(NP-C问题)：既是NP问题，也是NP-hard问题。例如，SAT问题（第一个NPC问题）。该问题的基本意思是，给定一系列布尔变量以及它的约束集，是否存在一个解使得它的输出为真。 相互关系：显然，所有P问题都是NP问题，反之则不一定。npc问题是np问题的子集，也是p问题和np问题的差异所在。如果找到一个多项式内能被解决的npc问题的解决方法，那么P=NP。 Ch2 线性表 线性表的存储方式 顺序存储方式 —— 顺序表 特点：存储利用率高，存取速度快 缺点：插入、删除等操作时需要移动大量数据 链表存储方式 —— 链表(单链表、循环链表、双向链表) 特点：适应表的动态增长和删除 缺点：需要额外的指针存储空间 单链表操作 插入 在链表的最前端插入 在链表中间插入 在链表末尾插入 删除 删除表中第一个元素 删除表中或表尾元素 带附加头结点（表头结点）的单链表： 表头结点位于表的最前端，本身不带数据，仅标志表头。 设置表头结点的目的是统一空表与非空表的操作，简化链表操作的实现。 循环链表操作：插入、删除 双向链表操作：插入、删除 双向循环链表操作：插入、删除 （算法）多项式及其运算 多项式顺序存储表示的缺点 插入和删除时项数可能有较大变化，因此要移动大量数据 不利于多个多项式的同时处理 多项式链表存储表示的优点 多项式的项数可以动态地增长，不存在存储溢出问题。 插入、删除方便，不移动元素 静态链表 为数组中每一个元素附加一个链接指针，就形成静态链表结构。 静态链表每个结点由两个数据成员构成：data域存储数据，link域存放链接指针。 Ch3 栈与队列 栈：后进先出（LIFO） 如何合理进行栈空间分配，以避免栈溢出或空间的浪费？ 双栈共享一个栈空间（多栈共享栈空间） 栈的链接存储方式—— 链式栈 栈的应用–表达式的计算（中缀、前缀、后缀） （算法）应用后缀表示计算表达式的值： 从左向右顺序地扫描表达式，并用一个栈暂存扫描到的操作数或计算结果。 扫描中遇操作数则压栈；遇操作符则从栈中退出两个操作数，计算后将结果压入栈 最后计算结果在栈顶 （算法）中缀表达式转换为后缀表达式： 操作符ch ; ( * / % + - ) isp(栈内) 0 1 5 3 6 icp(栈外) 0 6 4 2 1 操作符优先级相等的情况只出现在括号配对或栈底的 “;” 号与输入流最后的 “;” 号配对时 操作符栈初始化，将结束符 ‘;’ 进栈。然后读入中缀表达式字符流的首字符ch。 重复执行以下步骤，直到ch = ‘;’，同时栈顶的操作符也是 ‘;’，停止循环。 若 ch 是操作数直接输出，读入下一个字符 ch 若ch是操作符，判断ch的优先级icp和位于栈顶的操作符op的优先级isp： 若 icp(ch) &gt; isp(op)，令ch进栈，读入下一个字符ch。 若 icp(ch) &lt; isp(op)，退栈并输出。 若 icp(ch) == isp(op)，退栈但不输出，若退出的是“(”号读入下一个字符ch。 算法结束，输出序列即为所需的后缀表达式 （做题）中缀表达式转换为后缀表达式： 先对中缀表达式按运算优先次序加上括号； 再把操作符后移到右括号的后面并以就近移动为原则； 最后将所有括号消去。 队列：先进先出（FIFO） 进队：新元素在rear处加入，rear = rear + 1。 出队：取出下标为 front 的元素，front = front + 1 队空时：rear == front 队满时：rear == maxSize （假溢出） 解决假溢出的办法之一：将队列元素存放数组首尾相接，形成循环（环形）队列。 循环队列： 12345队头指针进1: front = (front+1) % maxSize;队尾指针进1: rear = (rear+1) % maxSize;队列初始化：front = rear = 0;队空条件：front == rear;队满条件：(rear+1) % maxSize == front 链式队列： 队头在链头，队尾在链尾。 链式队列在进队时无队满问题，但有队空问题。 队空条件为 front == NULL 优先级队列： 每次从队列中取出的是具有最高优先权(优先级)的元素 优先权是根据问题而定的 出现相同的优先权的元素时，按FIFO的方式处理 Ch4 数组、串与广义表 二维数组中数组元素的顺序存放： 行优先存放：设数组开始存放位置 LOC(0,0)=aLOC(0, 0) = aLOC(0,0)=a，每个元素占用 $l 个存储单元，LOC ( j, k ) = a + ( j * m + k ) * l$ 列优先存放：设数组开始存放位置 LOC(0,0)=aLOC(0, 0) = aLOC(0,0)=a， 每个元素占用 lll 个存储单元，LOC(j,k)=a+(k∗n+j)∗lLOC ( j, k ) = a + ( k * n + j ) * lLOC(j,k)=a+(k∗n+j)∗l 特殊矩阵：非零元素或零元素的分布有一定规律的矩阵 对称矩阵：为节约存储， 只存对角线及对角线以上的元素，或者只存对角线或对角线以下的元素。前者称为上三角矩阵，后者称为下三角矩阵。按行存放 三对角矩阵：除主对角线及在主对角线上 下最临近的两条对角线上的元素外， 所有其它元素均为0。总共有3n-2个非零元素。按行存放 稀疏矩阵 (Sparse Matrix) 每一个三元组 (i,j,aij)(i, j, a_{ij})(i,j,a​ij​​) 唯一确定了矩阵A的一个非零元素。 （算法）稀疏矩阵转置： 设矩阵列数为 Cols， 对矩阵三元组表扫描 Cols 次； 第 k 次扫描找寻所有列号为 k 的项， 将其行号变列号、列号变行号，顺次存于转置矩阵三元组表。 设矩阵三元组表总共有 t 项， 上述算法的时间代价为 O(n∗t)O ( n*t )O(n∗t)。 当非零元素的个数 t 和 m∗nm*nm∗n 同数量级时， 算法Transpose的时间复杂度为O(m∗n2)O(m*n^2)O(m∗n​2​​)。 （算法）稀疏矩阵快速转置： 为加速转置速度， 建立辅助数组 rowSize 和 rowStart： rowSize记录矩阵转置前各列，即转置矩阵各行非零元素个数； rowStart记录转置矩阵各行非零元素在转置三元组表中开始存放位置。 扫描矩阵三元组表，根据某项列号，确定它转置后的行号, 查 rowStart 表, 按查到的位置直接将该项存入转置三元组表中。 带行指针数组的二元组表 正交链表：适应矩阵操作(+、 -、 *)时矩阵非零元素的动态变化 字符串 (String) 空串和空白串不同，分别表示长度为1的空白串和长度为0的空串。 串中任意个连续字符组成的子序列称为该串的子串，包含子串的串相应地称为主串。 特别地，空串是任意串的子串，任意串是其自身的子串。 朴素的模式匹配算法：算法的运行时间为O(n∗m)O(n*m)O(n∗m)，低效的原因在于每趟重新比较时，目标串的检测指针要回退。但在一般情况下，实际的执行时间近似于O(n+m)O(n+m)O(n+m)，因此至今仍被采用。 （算法）KMP算法：算法的运行时间为O(n+m)O(n+m)O(n+m)，跳转 KMP最大的特点是指示主串的指针不需回溯，整个匹配过程中，对主串仅需要从头至尾扫描一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无需回头重读。 广义表 (General Lists ) 表元素，可以是表（ 称为子表）， 可以是数据元素（ 称为原子） n 为表的长度。 n = 0 的广义表为空表 n &gt; 0 时， 表的第一个表元素称为广义表的表头（ head），除此之外，其它表元素组成的表称为广义表的表尾（ tail） n = 0 时，表头表尾不存在 广义表的表示 广义表结点定义： 结点类型 utype： = 0, 表头； = 1, 原子数据；= 2, 子表 信息 info： utype = 0 时, 存放引用计数(ref)；utype = 1时, 存放数据值(value)； utype = 2时, 存放指向子表表头的指针(hlink) 尾指针tlink： utype = 0时, 指向该表第一个结点； utype != 0 时, 指向同一层下一个结点 广义表的递归算法 广义表的复制算法 求广义表深度的算法 广义表的删除算法 KMP算法跳转 Ch5 树与二叉树 树和森林的概念 有根树 一棵有根树T，简称为树，它是n (n ≥ 0) 个结点的有限集合。当n = 0时，T 称为空树；否则，T 是非空树。记作T={Φ,n=0{r,T1,T2,…,Tm},n&gt;0T=\\left\\{\\begin{array}{ll} \\Phi, &amp; n=0 \\\\ \\left\\{r, T_{1}, T_{2}, \\ldots, T_{m}\\right\\}, &amp; n&gt;0 \\end{array}\\right.T={​Φ,​{r,T​1​​,T​2​​,…,T​m​​},​​​n=0​n&gt;0​​ r 是一个特定的称为根 (root) 的结点，它只有直接后继，没有直接前驱 根以外的其他结点划分为 m (m&gt;=0) 个互不相交的有限集合T_1, T_2, …, T_m，每个集合又是一棵树，并且称为根的子树 每棵子树的根结点有且仅有一个直接前驱，但可以有0个或多个直接后继 树的基本术语 子女：若结点的子树非空，结点子树的根即为该结点的子女。 双亲（父亲）：若结点有子女，该结点是子女的双亲（父亲）。 兄弟：同一结点的子女互称为兄弟。 度：结点的子女个数即为该结点的度；树中各个结点的度的最大值称为树的度。 分支结点：度不为0的结点即为分支结点，亦称为非终端结点。 叶结点：度为0的结点即为叶结点，亦称为终端结点。 祖先：根结点到该结点的路径上的各个结点都是该结点的祖先。 子孙：某结点的所有下属结点，都是该结点的子孙。 结点的层次：规定根结点在第一层，其子女结点的层次等于它的层次加一。以下类推。 结点的深度：结点的深度即为结点的层次；离根最远结点的层次即为树的深度。 结点的高度：规定叶结点的高度为1，其双亲结点的高度等于它的高度加一。 树的高度：等于根结点的高度，即根结点所有子女高度的最大值加一。 有序树：树中结点的各棵子树 T1, T2, …是有次序的，即为有序树。 无序树：树中结点的各棵子树之间的次序是不重要的，可以互相交换位置。 森林：森林是m（m≥0）棵树的集合。 树的抽象数据类型 二叉树 二叉树的定义：一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。 二叉树的性质： 性质1 若二叉树结点的层次从 1 开始, 则在二叉树的第 i 层最多有 2i−12^{i-1}2​i−1​​ 个结点。( i≥1) 用数学归纳法证明 证明： ​ 归纳基础：i=1时，有2i−1=20=12^{i-1}=2^0=12​i−1​​=2​0​​=1。因为第1层上只有一个根结点，所以命题成立。 ​ 归纳假设：假设对所有的j(1≤j&lt;i)命题成立，即第j层上至多有2j−12^{j-1}2​j−1​​个结点，证明j=i时命题亦成立。 ​ 归纳步骤：根据归纳假设，第i-1层上至多有2i−22^{i-2}2​i−2​​个结点。由于二叉树的每个结点至多有两个孩子，故第i层上的结点数至多是第i-1层上的最大结点数的2倍。即j=i时，该层上至多有2×2^{i-2}=2^{i-1}个结点，故命题成立。 性质2 深度为 k 的二叉树最少有 k 个结点，最多有 2k−12^k-12​k​​−1个结点。( k≥1 ) 因为每一层最少要有1个结点，因此，最少结点数为 k。最多结点个数借助性质1：用求等比级数前k项和的公式：2^0 +2^1 +2^2 + …+2^{k-1} = 2^k-1 性质3 对任何一棵二叉树，如果其叶结点有 n0n_0n​0​​ 个，度为 2 的非叶结点有 n2n_2n​2​​ 个, 则有 n_0＝n_2＋1 若设度为 1 的结点有 n1n_1n​1​​ 个，总结点数为n，总边数为e，则根据二叉树的定义， n = n_0+n_1+n_2，e = 2n_2+n_1 = n-1 因此，有 $n_2 = n_0-1 $， n0=n2+1n_0 = n_2+1n​0​​=n​2​​+1 性质4 具有 n (n≥0) 个结点的完全二叉树的深度为⌈log2(n+1)⌉\\left\\lceil\\log _{2}(n+1)\\right\\rceil⌈log​2​​(n+1)⌉ 设完全二叉树的深度为k，则有 2k−1−1&lt;n⩽2k−12^{k-1}-1&lt;n \\leqslant 2^{k}-12​k−1​​−1&lt;n⩽2​k​​−1（上面k-1层结点数；包括第k层的最大结点数） 变形 2k−1&lt;n+1⩽2k2^{k-1}&lt;n+1 \\leqslant 2^{k}2​k−1​​&lt;n+1⩽2​k​​ 取对数 k−1&lt;log2(n+1)⩽kk-1&lt;\\log _{2}(n+1) \\leqslant kk−1&lt;log​2​​(n+1)⩽k 得到 ⌈log2(n+1)⌉=k\\left\\lceil\\log _{2}(n+1)\\right\\rceil=k⌈log​2​​(n+1)⌉=k 性质5 如将一棵有n个结点的完全二叉树自顶向下，同一层自左向右连续给结点编号1, 2, …, n，则有以下关系： 若i = 1, 则 i 无双亲 若i &gt; 1, 则 i 的双亲为⌊i/2⌋\\lfloor i / 2\\rfloor⌊i/2⌋ 若2∗i&lt;=n2*i &lt;= n2∗i&lt;=n, 则 i 的左子女为 2∗i2* i2∗i 若2∗i+1&lt;=n2*i+1 &lt;= n2∗i+1&lt;=n, 则 i 的右子女为2∗i+12*i+12∗i+1 若 i 为奇数, 且i != 1，则其左兄弟为i-1 若 i 为偶数, 且i != n，则其右兄弟为i+1 满二叉树 (Full Binary Tree)：深度为 k 的满二叉树是有 2k−12^{k}-12​k​​−1个结点的二叉树。 完全二叉树 (Complete Binary Tree)：若设二叉树的深度为 k，则共有 k 层。除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k层从右向左连续缺若干结点，这就是完全二叉树。 二叉树的抽象数据类型 二叉树的顺序表示 二叉树的链表表示（二叉链表） 二叉树结点定义：每个结点有3个成员，data域存储结点数据，leftChild 和 rightChild 分别存放指向左子女和右子女的指针。 二叉树的链表表示（三叉链表） 每个结点增加一个指向双亲的指针parent，使得查找双亲也很方便 三叉链表的静态结构 二叉树遍历 二叉树的遍历就是按某种次序访问树中的结点，要求每个结点访问一次且仅访问一次。 （算法）中序遍历 (Inorder Traversal) 若二叉树为空，则直接返回； 否则： 中序遍历左子树 (L)； 访问根结点 (V)； 中序遍历右子树 ® （算法）前序遍历 (Preorder Traversal) 若二叉树为空，则直接返回； 否则： 访问根结点 (V)； 前序遍历左子树 (L)； 前序遍历右子树 ®。 （算法）后序遍历 (Postorder Traversal) 若二叉树为空，则直接返回； 否则 后序遍历左子树 (L)； 后序遍历右子树 ®； 访问根结点 (V)。 （算法）利用二叉树前序遍历建立二叉树 （算法）层次遍历二叉树的算法 层次遍历二叉树就是从根结点开始，按层次逐层遍历 这种遍历需要使用一个先进先出队列，在处理上一层时，将其下一层的结点直接进到队列（的队尾）。在上一层结点遍历完后，下一层结点正好处于队列的队头，可以继续访问它们。 算法是非递归的。 由给定的前序序列和中序序列能够唯一地确定一棵二叉树（或者后序遍历和中序遍历） 证明：通过先序序列找到根结点和末尾元素，因为先序和后续最后遍历的都是右子树，所以末尾相同元素即为根节点的右子树，不断对比，每找到一棵子树的根结点就用斜线将其左右与其他元素断开分成一颗颗子树。 由给定的前序序列和后序序列不能唯一地确定一棵二叉树 线索化二叉树 又称为穿线树。 通过二叉树的遍历，可将二叉树中所有结点的数据排列在一个线性序列中，可以找到某数据在这种排列下它的前驱和后继。 希望不必每次都通过遍历找出这样的线性序列。只要事先做预处理，将某种遍历顺序下的前驱、后继关系记在树的存储结构中，以后就可以高效地找出某结点的前驱、后继。 方法一：增加 Pred 指针和 Succ 指针的二叉树 这种设计的缺点是每个结点增加两个指针，当结点数很大时存储消耗较大。 对于原来的二叉链表结构，一棵n个结点的二叉树共有2n个指针域，而非空的指针域为n-1个，因此，仍有n+1个指针域没有利用起来。 方法二：增加左右线索标志的二叉树 改造树结点，将 pred 指针和 succ 指针压缩到 leftChild 和 rightChild 的空闲指针中，并增设两个标志 ltag 和 rtag，指明指针是指示子女还是前驱／后继。后者称为线索。 ltag (或rtag) = 0，表示相应指针指示左子女（或右子女结点）；当ltag (或rtag) = 1, 表示相应指针为前驱（或后继）线索。 线索化二叉树及其链表表示 前序线索化二叉树 后序线索化二叉树 树与森林 树(一般的树)的存储表示 广义表表示 双亲表示 树中结点的存放顺序一般不做特殊要求，但为了操作实现的方便，有时也会规定结点的存放顺序。例如，可以规定按树的前序次序存放树中的各个结点，或规定按树的层次次序安排所有结点。 子女链表表示 子女指针表示 一个合理的想法是在结点中存放指向每一个子女结点的指针。但由于各个结点的子女数不同，每个结点设置数目不等的指针，将很难管理。 为此，设置等长的结点，每个结点包含的指针个数相等，等于树的度（degree）。 这保证结点有足够的指针指向它的所有子女结点。但可能产生很多空闲指针，造成存储浪费。 子女-兄弟表示 firstChild 指向该结点的第一个子女结点。无序树时，可任意指定一个结点为第一个子女。 nextSibling 指向该结点的下一个兄弟。任一结点在存储时总是有顺序的。 若想找某结点的所有子女，可先找firstChild,再反复用 nextSibling 沿链扫描。 树的遍历 深度优先遍历 先根次序遍历 当树非空时：访问根结点；依次先根遍历根的各棵子树 树的先根遍历结果与其对应二叉树表示的前序遍历结果相同 树的先根遍历可以借助对应二叉树的前序遍历算法实现 后根次序遍历 当树非空时，依次后根遍历根的各棵子树；访问根结点 树的后根遍历结果与其对应二叉树表示的中序遍历结果相同 树的后根遍历可以借助对应二叉树的中序遍历算法实现 广度优先（层次次序）遍历 若树非空，则根结点入队 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队 树与二叉树的转换：孩子兄弟表示法 森林与二叉树的转换 将一般树化为二叉树表示就是用树的子女-兄弟表示来存储树的结构。 森林与二叉树表示的转换可以借助树的二叉树表示来实现。 森林转化成二叉树的规则 若 F 为空，即 n = 0，则对应的二叉树 B 为空树。 若 F 不空，则 二叉树 B 的根是 F 第一棵树 T1 的根； 其左子树为B (T_{11}, T_{12}, …, T_{1m})，其中，T_{11}, T_{12}, …, T_{1m }是 T1T_1T​1​​ 的根的子树； 其右子树为$ B (T_2, T_3, …, T_n)，其中，T_2, T_3, …, T_n$ 是除 T1T_1T​1​​ 外其它树构成的森林。 二叉树转换为森林的规则 如果 B 为空，则对应的森林 F 也为空。 如果 B 非空，则 F 中第一棵树$ T_1$ 的根为 B 的根； T1T_1T​1​​ 的根的子树森林 \\{ T_{11}, T_{12}, …, T_{1m} \\} 是由 B 的根的左子树 LB 转换而来； F 中除了 T1T_1T​1​​ 之外其余的树组成的森林$ { T_2, T_3, …, T_n } $是由 B 的根的右子树 RB 转换而成的森林。 森林的先序遍历 若森林为非空，则按照如下规则进行遍历： 访问森林中第一棵树的根结点 先序遍历第一棵树中根节点的子树森林 先序遍历除去第一棵树之后剩余的树构成的森林 森林的中序遍历（效果等同于依次对二叉树的中序遍历） 若森林为非空，则按照如下规则进行遍历： 中序遍历森林中第一棵树的根节点的子树森林 访问第一棵树的根节点 中序遍历除去第一棵树之后剩余的树构成的森林 堆(Heap) 优先级队列 每次出队列的是优先权最高的元素。 用堆实现其存储表示，能够高效运作。 堆的元素下标计算 由于堆存储在下标从 0 开始计数的一维数组中，因此在堆中给定下标为 i 的结点时 如果 i = 0，结点 i 是根结点，无双亲；否则结点 i 的父结点为结点 ⌊(i−1)/2⌋\\lfloor(i-1) / 2\\rfloor⌊(i−1)/2⌋； 如果 2i+1＞n-1，则结点 i 无左子女；否则结点 i 的左子女为结点 2i+1； 如果 2i+2＞n-1，则结点 i 无右子女；否则结点 i 的右子女为结点 2i+2。 （算法）最小堆的下滑调整算法 （算法）最小堆的插入：每次插入都加在堆的最后，再自下向上执行调整，使之重新形成堆，时间复杂性O(log2n)O(log_2n)O(log​2​​n) （算法）最小堆的向上调整 （算法）最小堆的删除算法 Huffman树 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w_1、w_2、…、w_n，则哈夫曼树的构造规则为： 将w_1、w_2、…、w_n看成是有n 棵树的森林(每棵树仅有一个结点)； 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 从森林中删除选取的两棵树，并将新树加入森林； 重复2、3步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。","categories":[{"name":"12-未分类","slug":"12-未分类","permalink":"https://dragonliu2021.github.io/categories/12-未分类/"}],"tags":[]},{"title":"双指针","slug":"双指针","date":"2022-04-19T05:33:16.000Z","updated":"2022-04-19T05:49:35.553Z","comments":true,"path":"2022/04/19/双指针/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/双指针/","excerpt":"","text":"1 算法解释 双指针顾名思义，就是同时使用两个指针，在序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过同向或相向移动来维护、统计信息。 双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。 若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。 2 题型分类 2.1 Two Sum 2.1.1 模板题——167. 两数之和 II - 输入有序数组 在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。 2.1.2 输入输出样例 输入是一个数组（numbers）和一个给定值（target）。输出是两个数的位置，从 1 开始计数。 12Input: numbers = [2,7,11,15], target = 9Output: [1,2] 在这个样例中，第一个数字（2）和第二个数字（7）的和等于给定值（9）。 2.1.3 题解 因为数组已经排好序，我们可以采用方向相反的双指针来寻找这两个数字，一个初始指向最小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。 如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。如果两个指针指向元素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。如果两个指针指向元素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。 1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int l = 0, r = numbers.size() - 1, sum; while (l &lt; r) &#123; sum = numbers[l] + numbers[r]; if (sum &gt; target) &#123; r--; &#125; else if (sum == target) &#123; break; &#125; else &#123; l++; &#125; &#125; return vector&lt;int&gt; &#123;l + 1, r + 1&#125;;&#125; 2.2 归并两个有序数组 2.2.1 模板题——88. 合并两个有序数组 给定两个有序数组，把两个数组合并为一个。 2.2.2 输入输出样例 输入是两个数组和它们分别的长度 m 和 n。其中第一个数组的长度被延长至 m + n，多出的 n 位被 0 填补。题目要求把第二个数组归并到第一个数组上，不需要开辟额外空间。 12Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3Output: nums1 = [1,2,2,3,5,6] 2.2.3 题解 因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即 nums1 的 m - 1 位和 nums2 的 n - 1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针，以便复制。 在以下的代码里，我们直接利用 m 和 n 当作两个数组的指针，再额外创立一个 pos 指针，起始位置为 m + n - 1。每次向前移动 m 或 n 的时候，也要向前移动 pos。这里需要注意，如果 nums1 的数字已经复制完，不要忘记把 nums2 的数字继续复制；如果 nums2 的数字已经复制完，剩余 nums1 的数字不需要改变，因为它们已经被排好序。 123456789void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int pos = (m--) + (n--) - 1; while (m &gt;= 0 &amp;&amp; n &gt;= 0) &#123; nums1[pos--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--]; &#125; while (n &gt;= 0) &#123; nums1[pos--] = nums2[n--]; &#125;&#125; 2.3 快慢指针 2.3.1 模板题——142. 环形链表 II 给定一个链表，如果有环路，找出环路的开始点。 2.3.2 输入输出样例 输入是一个链表，输出是链表的一个节点。如果没有环路，返回一个空指针。 如果没有特殊说明， LeetCode 采用如下的数据结构表示链表。 12345struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) &#123;&#125;&#125;; 2.3.3 题解 对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd 判圈法） 。给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步， slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路；如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。 证明： 慢指针入环第一圈没走完的时候就会和快指针相遇 $a=c+(n-1)(b+c)a=c+(n−1)(b+c) $的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1​ 圈的环长，恰好等于从链表头部到入环点的距离。 1234567891011121314151617ListNode *detectCycle(ListNode *head) &#123; ListNode *fast = head, *slow = head; // 判断是否存在环路 do &#123; if (!fast || !fast-&gt;next) return nullptr; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; while (fast != slow); // 如果存在，查找环路节点 fast = head; while (fast != slow) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast;&#125; 2.4 滑动窗口 2.4.1 模板题——76. 最小覆盖子串 给定两个字符串 S 和 T，求 S 中包含 T 所有字符的最短连续子字符串的长度，同时要求时间复杂度不得超过 O(n)O(n)O(n)​。 2.4.2 输入输出样例 输入是两个字符串 S 和 T，输出是一个 S 字符串的子串。 12Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot; 在这个样例中， S 中同时包含一个 A、一个 B、一个 C 的最短子字符串是“BANC”。 2.4.3 题解 本题使用滑动窗口求解，即两个指针 l 和 r 都是从最左端向最右端移动，且 l 的位置一定在 r 的左边或重合。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。 注意本题虽然在 for 循环里出现了一个 while 循环，但是因为 while 循环负责移动 l 指针，且 l 只会从左到右移动一次，因此总时间复杂度仍然是 O(n)O(n)O(n)。本题使用了长度为 128 的数组来映射字符，也可以用哈希表替代；其中chars 表示目前每个字符缺少的数量， flag 表示每个字符是否在 T 中存在。 123456789101112131415161718192021222324252627282930313233string minWindow(string s, string t) &#123; vector&lt;int&gt; chars(128, 0); vector&lt;bool&gt; flag(128, false); // 先统计T中的字符情况 for (auto ch : t) &#123; flag[ch] = true; ++chars[ch]; &#125; // 移动滑动窗口， 不断更改统计数据 int slen = s.size(); int tlen = t.size(); int cnt = 0, l = 0, min_l = 0, min_size = slen + 1; for (int r =0; r &lt; slen; ++r) &#123; if (flag[s[r]]) &#123; if (--chars[s[r]] &gt;= 0) &#123; ++cnt; &#125; // 若目前滑动窗口已包含T中全部字符， // 则尝试将l右移， 在不影响结果的情况下获得最短子字符串 while (cnt == tlen) &#123; if (r - l + 1 &lt; min_size) &#123; min_l = l; min_size = r - l + 1; &#125; if (flag[s[l]] &amp;&amp; ++chars[s[l]] &gt; 0) &#123; --cnt; &#125; ++l; &#125; &#125; &#125; return min_size &gt; slen ? \"\" : s.substr(min_l, min_size);&#125; 3 注意 4 参考 OI-wiki 5 题目列表 需要配合OI-wiki刷题 试题链接 解题链接 备注 167. 两数之和 II - 输入有序数组 - Two Sum模板 88. 合并两个有序数组 - 模板题目 142. 环形链表 II - 模板题目 76. 最小覆盖子串 - 模板题目 633. 平方数之和 - Two Sum变形，用long long 680. 验证回文字符串 Ⅱ - Two Sum变形，只允许一次失误，可以选择从左或右边跳过 1 无重复字符的最长子串 题目来源：leetcode-3 无重复字符的最长子串 思路 首先区分子串与子序列：子串必须连续，子序列可以不连续。 两层循环O(n2)O(n^2)O(n​2​​)不太行，减少重复查询，可以用双指针维护一个滑动窗口，同时用一个数组标记滑动窗口内出现的字符。 时间复杂度：O(N)O(N)O(N)，其中 NNN 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。 空间复杂度：O(∣Σ∣)O(|\\Sigma|)O(∣Σ∣)，其中 Σ\\SigmaΣ 表示字符集（即字符串中可以出现的字符），∣Σ∣|\\Sigma|∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128)[0, 128)[0,128) 内的字符，即 ∣Σ∣=128|\\Sigma| = 128∣Σ∣=128。 代码 123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; const int maxn = 128;//字符范围 int foot[maxn] = &#123;0&#125;;//标记滑动窗口中已经有的字符 int len = s.size(); if (len == 0) &#123;//空串 return 0; &#125; int start = 0, end = 0;//双指针维护窗口 foot[s[start]] = 1; int ans = 1; while (start &lt; len - 1) &#123; end++;//后面的指针前进 while (end &lt; len) &#123; if (foot[s[end]] == 0) &#123; foot[s[end]] = 1; end++; &#125; else &#123; break; &#125; &#125; end--;//后面的指针回退 ans = max(ans, end - start + 1); foot[s[start]] = 0;//前面的指针前移 start++; &#125; return ans; &#125;&#125;;","categories":[{"name":"11-技巧","slug":"11-技巧","permalink":"https://dragonliu2021.github.io/categories/11-技巧/"}],"tags":[]},{"title":"前缀和与差分","slug":"前缀和与差分","date":"2022-04-19T05:32:35.000Z","updated":"2022-04-19T05:32:59.790Z","comments":true,"path":"2022/04/19/前缀和与差分/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/前缀和与差分/","excerpt":"","text":"OI-Wiki 前缀和 &amp; 差分 1 前缀和 前缀和是一种重要的预处理，能大大降低查询的时间复杂度。可以简单理解为“数列的前 nnn​ 项的和”。 C++ 标准库中实现了前缀和函数 std::partial_sum，定义于头文件 &lt;numeric&gt; 中。 * 1.1 二维/多维前缀和 * 1.2 基于 DP 计算高维前缀和 * 1.3 树上前缀和 2 差分 差分是一种和前缀和相对的策略，可以当做是求和的逆运算。 这种策略的定义是令 bi={ai−ai−1i∈[2,n]a1i=1b_{i}= \\begin{cases}a_{i}-a_{i-1} &amp; i \\in[2, n] \\\\ a_{1} &amp; i=1\\end{cases}b​i​​={​a​i​​−a​i−1​​​a​1​​​​​i∈[2,n]​i=1​​ 简单性质： aia_{i}a​i​​ 的值是 bib_{i}b​i​​ 的前缀和，即 an=∑i=1nbia_{n}=\\sum_{i=1}^{n} b_{i}a​n​​=∑​i=1​n​​b​i​​ 计算 aia_{i}a​i​​ 的前缀和 \\operatorname{sum}=\\sum_{i=1}^{n} a_{i}=\\sum_{i=1}^{n} \\sum_{j=1}^{i} b_{j}=\\sum_{i}^{n}(n-i+1) b_{i} 它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。 譬如使 [l,r][l, r][l,r] 中的每个数加上一个 kkk, 即 bl←bl+k,br+1←br+1−kb_{l} \\leftarrow b_{l}+k, b_{r+1} \\leftarrow b_{r+1}-k b​l​​←b​l​​+k,b​r+1​​←b​r+1​​−k 其中 bl+k=al+k−al−1,br+1−k=ar+1−(ar+k)b_{l}+k=a_{l}+k-a_{l-1}, b_{r+1}-k=a_{r+1}-\\left(a_{r}+k\\right)b​l​​+k=a​l​​+k−a​l−1​​,b​r+1​​−k=a​r+1​​−(a​r​​+k) 最后做一遍前缀和就好了。 C++ 标准库中实现了差分函数 std::adjacent_difference，定义于头文件 &lt;numeric&gt; 中。 * 2.1 树上差分 * 2.1.1 点差分 * 2.1.2 边差分","categories":[{"name":"11-技巧","slug":"11-技巧","permalink":"https://dragonliu2021.github.io/categories/11-技巧/"}],"tags":[]},{"title":"贪心算法","slug":"贪心算法","date":"2022-04-19T05:31:47.000Z","updated":"2022-04-19T05:32:02.830Z","comments":true,"path":"2022/04/19/贪心算法/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/贪心算法/","excerpt":"","text":"1 简介 贪心算法（英语：greedy algorithm），是用计算机来模拟一个“贪心”的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。 可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。 2 适用范围 贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。 3 证明方法 贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。 反证法：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。 归纳法：先算出边界情况（例如n=1n=1n=1 ）的最优解F1F_1F​1​​，然后再证明：对于每个nnn，Fn+1F_{n+1}F​n+1​​ 都可以由FnF_nF​n​​推导出结果。 4 与动态规划的区别 贪心算法：对每个子问题的解决方案都做出选择，不能回退。 动态规划：则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。 5 解题 5.1 常见题型 在提高组难度以下的题目中，最常见的贪心有两种。 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。 「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护） 二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。 5.2 排序解法 用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。 5.3 后悔解法 思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。 5.4 注意 预处理：在处理数组前，统计一遍信息（如频率、个数、第一次出现位置、最后一次出现位置等）可以使题目难度大幅降低。 6 参考 OI-wiki 7 题目列表 试题链接 解题链接 备注 Leetcode 455. 分发饼干 - 排序 Leetcode 135. 分发糖果 - 两次遍历 Leetcode 435. 无重叠区间 - 区间问题 Leetcode 605. 种花问题 - - 452. 用最少数量的箭引爆气球 - 和435类似 763. 划分字母区间 - 预处理 122. 买卖股票的最佳时机 II - 累加所有的上坡 406. 根据身高重建队列 解法 二维排序，插入 665. 非递减数列 数学规律解法 逆序对，数学规律，未用贪心","categories":[{"name":"09-算法","slug":"09-算法","permalink":"https://dragonliu2021.github.io/categories/09-算法/"}],"tags":[]},{"title":"动态规划","slug":"动态规划","date":"2022-04-19T05:30:43.000Z","updated":"2022-04-19T05:31:29.793Z","comments":true,"path":"2022/04/19/动态规划/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/动态规划/","excerpt":"","text":"1 最大子序和 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 链接：https://leetcode-cn.com/problems/maximum-subarray/ 思路 状态：dp[i]dp[i]dp[i] 代表以nums[i]nums[i]nums[i]结尾的最大和 状态转移方程：dp[i]=max(dp[i−1]+nums[i],nums[i])dp[i] = max(dp[i-1]+nums[i], nums[i])dp[i]=max(dp[i−1]+nums[i],nums[i]) 答案：max(dp[0...n−1])max(dp[0...n-1])max(dp[0...n−1]) 时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)O(n)O(n)。 空间复杂度：O(n)O(n)O(n)，可用滚动数组优化到O(1)O(1)O(1)。 代码 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int pre = nums[0]; int ans = nums[0]; for (int i = 1; i &lt; n; i++) &#123; pre = max(nums[i], pre + nums[i]); ans = max(ans, pre); &#125; return ans; &#125;&#125;; 2 最长上升子序列 题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/ 思路 状态：dp[i]dp[i]dp[i] 代表以nums[i]nums[i]nums[i]结尾的最长严格递增子序列的长度 状态转移方程：dp[i]=max(dp[j]+1,dp[i])dp[i] = max(dp[j]+1,dp[i])dp[i]=max(dp[j]+1,dp[i])，j&lt;ij&lt;ij&lt;i且nums[i]&gt;nums[j]nums[i]&gt;nums[j]nums[i]&gt;nums[j] 答案：max(dp[0…n-1]) 时间复杂度： O(n2)O(n^2)O(n​2​​) 空间复杂度： O(n)O(n)O(n) 代码 1234567891011121314151617class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int dp[n]; dp[0] = 1; for (int i = 1; i &lt; n; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; return *max_element(dp, dp + n); &#125;&#125;; 3","categories":[{"name":"09-算法","slug":"09-算法","permalink":"https://dragonliu2021.github.io/categories/09-算法/"}],"tags":[]},{"title":"背包dp","slug":"背包dp","date":"2022-04-19T05:29:39.000Z","updated":"2022-04-19T05:31:10.118Z","comments":true,"path":"2022/04/19/背包dp/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/背包dp/","excerpt":"","text":"转载：dd大牛的《背包九讲》、背包问题九讲、知乎转载 P01: 01背包 题目 有N件物品和一个容量为V的背包。第i件物品的费用/体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。 基本思路 这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即f[i][v]f[i][v]f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max{f[i−1][v],f[i−1][v−c[i]]+w[i]}f[i][v]=max\\{f[i-1][v],f[i-1][v-c[i]]+w[i]\\}f[i][v]=max{f[i−1][v],f[i−1][v−c[i]]+w[i]}。 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f[i−1][v−c[i]]f [i-1][v-c[i]]f[i−1][v−c[i]]再加上通过放入第i件物品获得的价值w[i]w[i]w[i]。 注意f[i][v]f[i][v]f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N][V]f[N] [V]f[N][V]，而是f[N][0...V]f[N][0...V]f[N][0...V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v−1]f[i][v-1]f[i][v−1]，这样就可以保证f[N][V]f[N] [V]f[N][V]就是最后的答案。 优化——空间复杂度 以上方法的时间和空间复杂度均为O(N∗V)O(N*V)O(N∗V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)O(V)O(V)。 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1...Ni=1...Ni=1...N，每次算出来二维数组f[i][0..V]f[i][0..V]f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]f [0..V]f[0..V]，能不能保证第iii次循环结束后f[v]f[v]f[v]中表示的就是我们定义的状态f[i][v]f[i][v]f[i][v]呢？f[i][v]f[i][v]f[i][v]是由f[i−1][v]f[i-1][v]f[i−1][v]和f[i−1][v−c[i]]f[i-1] [v-c[i]]f[i−1][v−c[i]]两个子问题递推而来，能否保证在推f[i][v]f[i][v]f[i][v]时（也即在第iii次主循环中推f[v]f[v]f[v]时）能够得到f[i−1][v]f[i-1][v]f[i−1][v]和f[i−1][v−c[i]]f[i-1][v -c[i]]f[i−1][v−c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0v=V..0v=V..0的顺序推f[v]f[v]f[v]，这样才能保证推f[v]f[v]f[v]时f[v−c[i]]f[v-c[i]]f[v−c[i]]保存的是状态f[i−1][v−c[i]]f[i -1][v-c[i]]f[i−1][v−c[i]]的值。伪代码如下： 123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 其中的f[v]=max{f[v],f[v−c[i]]+w[i]}f[v]=max\\{f[v],f[v-c[i]]+w[i]\\}f[v]=max{f[v],f[v−c[i]]+w[i]}一句恰就相当于我们的转移方程f[i][v]=max{f[i−1][v],f[i−1][v−c[i]]+w[i]}f[i][v]=max\\{f[i-1][v],f[i- 1][v-c[i]]+w[i]\\}f[i][v]=max{f[i−1][v],f[i−1][v−c[i]]+w[i]}，因为现在的f[v−c[i]]f[v-c[i]]f[v−c[i]]就相当于原来的f[i−1][v−c[i]]f[i-1][v-c[i]]f[i−1][v−c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]f[i][v]f[i][v]由f[i][v−c[i]]f[i][v-c[i]]f[i][v−c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 代码实现 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;//物品最大数量const int maxv = 1e3 + 5;//背包最大体积int dp[maxv];//背包int volume[maxn], value[maxn];//每个物品的体积和价值int n, v;//总物品数、背包体积//01背包 每种物品仅有一件，可以选择放或不放void zero_one_park(int val, int vol) &#123; for (int j = v; j &gt;= vol; j--) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt; volume[i]&gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; zero_one_park(value[i], volume[i]); &#125; cout&lt;&lt; dp[v]&lt;&lt; endl; return 0;&#125; 小结 01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 练习 acwing模板题——01背包问题 P02: 完全背包问题 题目 有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路 这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]f[i][v]f[i][v]表示前iii种物品恰放入一个容量为vvv的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0&lt;=k∗c[i]&lt;=v}f[i][v]=max\\{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;= v\\}f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0&lt;=k∗c[i]&lt;=v}。这跟01背包问题一样有O(N∗V)O(N*V)O(N∗V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]f[i][v]f[i][v]的时间是O(v/c[i])O(v/c[i])O(v/c[i])，总的复杂度是超过O(VN)O(VN)O(VN)的。 将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 优化 一个简单有效的优化 完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]c[i]&lt;=c[j]c[i]&lt;=c[j]且w[i]&gt;=w[j]w[i]&gt;=w[j]w[i]&gt;=w[j]，则将物品jjj去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的jjj换成物美价廉的iii，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 转化为01背包问题求解 既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c[i]V/c [i]V/c[i]件，于是可以把第iii种物品转化为V/c[i]V/c[i]V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 更高效的转化方法是：把第i种物品拆成费用为c[i]∗2kc[i]*2^kc[i]∗2​k​​、价值为w[i]∗2kw[i]*2^kw[i]∗2​k​​的若干件物品，其中kkk满足c[i]∗2k&lt;Vc[i]*2^k&lt;Vc[i]∗2​k​​&lt;V。这是二进制的思想，因为不管最优策略选几件第iii种物品，总可以表示成若干个2k2^k2​k​​件物品的和。这样把每种物品拆成O(log(V/c[i]))O(log(V/c[i]))O(log(V/c[i]))件物品，是一个很大的改进。但我们有更优的O(VN)O(VN)O(VN)的算法。 O(VN)O(VN)O(VN)的算法 这个算法使用一维数组，先看伪代码： 123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0v=V..0v=V..0的逆序来循环。这是因为要保证第iii次循环中的状态f[i][v]f[i][v]f[i][v]是由状态f[i−1][v−c[i]]f[i-1][v-c[i]]f[i−1][v−c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第iii件物品”这件策略时，依据的是一个绝无已经选入第iii件物品的子结果f[i−1][v−c[i]]f[i-1][v-c[i]]f[i−1][v−c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第iii种物品”这种策略时，却正需要一个可能已选入第iii种物品的子结果f[i][v−c[i]]f[i][v-c[i]]f[i][v−c[i]]，所以就可以并且必须采用v=0..Vv= 0..Vv=0..V的顺序循环。这就是这个简单的程序为何成立的道理。 这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[i][v]=max{f[i−1][v],f[i][v−c[i]]+w[i]}f[i][v]=max\\{f[i-1][v],f[i][v-c[i]]+w[i]\\}f[i][v]=max{f[i−1][v],f[i][v−c[i]]+w[i]}，将这个方程用一维数组实现，便得到了上面的伪代码。 代码实现 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;//物品最大数量const int maxv = 1e3 + 5;//背包最大体积int dp[maxv];//背包int volume[maxn], value[maxn];//每个物品的体积和价值int n, v;//总物品数、背包体积//完全背包 每种物品都有无限件可用void complete_park(int val, int vol) &#123; for (int j = vol; j &lt;= v; j++) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt; volume[i]&gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; complete_park(value[i], volume[i]); &#125; cout&lt;&lt; dp[v]&lt;&lt; endl; return 0;&#125; 小结 完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。 练习 acwing模板题——完全背包问题 P03: 多重背包问题 题目 有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路 这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第iii种物品有n[i]+1n[i]+1n[i]+1种策略：取0件，取1件……取 n[i]n[i]n[i]件。令f[i][v]f[i][v]f[i][v]表示前iii种物品恰放入一个容量为vvv的背包的最大权值，则：f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0&lt;=k&lt;=n[i]}f[i][v]=max\\{f[i-1][v-k*c[i]]+ k*w[i]|0&lt;=k&lt;=n[i]\\}f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0&lt;=k&lt;=n[i]}。复杂度是O(V*∑n[i])。 优化 转化为01背包问题 另一种好想好写的基本方法是转化为01背包求解：把第iii种物品换成n[i]n[i]n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，复杂度仍然是O(V*∑n[i])。 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第iii种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]0..n[i]0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]n[i]n[i]件的策略必不能出现。 方法是：将第iii种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2k−1,n[i]−2k+11,2,4,...,2^{k-1},n[i]-2^k+11,2,4,...,2​k−1​​,n[i]−2​k​​+1，且kkk是满足n[i]−2k+1&gt;0n[i]-2^k+1&gt;0n[i]−2​k​​+1&gt;0的最大整数。例如，如果n[i]n[i]n[i]为131313，就将这种物品分成系数分别为1,2,4,61,2,4,61,2,4,6的四件物品。 分成的这几件物品的系数和为n[i]n[i]n[i]，表明不可能取多于n[i]n[i]n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]0..n[i]0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2k−10..2^{k-1}0..2​k−1​​和2k..n[i]2^k..n[i]2​k​​..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 这样就将第iii种物品分成了O(logn[i])O(log n[i])O(logn[i])种物品，将原问题转化为了复杂度为O(V*∑log n[i])的01背包问题，是很大的改进。 * O(VN)O(VN)O(VN)的算法 多重背包问题同样有O(VN)O(VN)O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)O(1)O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;//物品最大数量const int maxv = 1e3 + 5;//背包最大体积int dp[maxv];//背包int volume[maxn], value[maxn], c[maxn];//每个物品的体积和价值、数量int n, v;//总物品数、背包体积//01背包 每种物品仅有一件，可以选择放或不放void zero_one_park(int val, int vol) &#123; for (int j = v; j &gt;= vol; j--) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;//完全背包 每种物品都有无限件可用void complete_park(int val, int vol) &#123; for (int j = vol; j &lt;= v; j++) &#123; dp[j] = max(dp[j], dp[j - vol] + val); &#125;&#125;//多重背包 每种物品都有限件可用void multiple_park(int val, int vol, int amount) &#123; if (vol * amount &gt;= v) &#123;//该种物品足以装满背包，转化为完全背包 complete_park(val, vol); &#125; else &#123;//转化为01背包，将第i种物品分成若干件物品 int k = 1; while (k &lt; amount) &#123; zero_one_park(k * val, k * vol); amount -= k; k &lt;&lt;= 1; &#125; if (amount &gt; 0) &#123; zero_one_park(amount * val, amount * vol); &#125; &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; c[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; multiple_park(value[i], volume[i], c[i]); &#125; cout&lt;&lt; dp[v]&lt;&lt; endl; return 0;&#125; 小结 这里我们看到了将一个算法的复杂度由O(V*∑n[i])改进到O(V*∑log n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。 练习 acwing模板题——多重背包问题 I acwing模板题——多重背包问题 II：本题考查多重背包的二进制优化方法。 P04: 混合三种背包问题 题目 如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？ 01背包与完全背包的混合 考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)O(VN)O(VN)。伪代码如下： 1234567for i=1..N if 第i件物品是01背包 for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; else if 第i件物品是完全背包 for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 再加上多重背包 如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)O(VN)O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(logn[i])O(log n[i])O(logn[i])个01背包的物品的方法也已经很优了。 小结 有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。 练习 acwing模板题——混合背包问题 P05: 二维费用的背包问题 题目 二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]a[i]a[i]和b[i]b[i]b[i]。两种代价可付出的最大值（两种背包容量）分别为VVV和UUU。物品的价值为w[i]w[i]w[i]。 算法 费用加了一维，只需状态也加一维即可。设f[i][v][u]f[i][v][u]f[i][v][u]表示前iii件物品付出两种代价分别为vvv和uuu时可获得的最大价值。状态转移方程就是：f[i][v][u]=maxf[i−1][v][u],f[i−1][v−a[i]][u−b[i]]+w[i]f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}f[i][v][u]=maxf[i−1][v][u],f[i−1][v−a[i]][u−b[i]]+w[i]。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量vvv和uuu采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。 物品总个数的限制 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取MMM件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为111，可以付出的最大件数费用为MMM。换句话说，设f[v][m]f[v][m]f[v][m]表示付出费用vvv、最多选mmm件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]f[0..V][0..M]f[0..V][0..M]范围内寻找答案。 另外，如果要求“恰取M件物品”，则在f[0..V][M]f[0..V][M]f[0..V][M]范围内寻找答案。 代码实现 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;//物品最大数量const int maxv = 1e2 + 5;//背包最大体积const int maxw = 1e2 + 5;//背包最大承受重量int dp[maxv][maxw];//背包int volume[maxn], value[maxn], weight[maxn];//每个物品的体积和价值、重量int n, v, w;//总物品数、背包体积、背包承受重量//二维01背包void two_dimension_park(int val, int wei, int vol) &#123; for (int j = v; j &gt;= vol; j--) &#123; for (int k = w; k &gt;= wei; k--) &#123; dp[j][k] = max(dp[j][k], dp[j - vol][k - wei] + val); &#125; &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v&gt;&gt; w; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt; volume[i]&gt;&gt; weight[i]&gt;&gt; value[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; two_dimension_park(value[i], weight[i],volume[i]); &#125; cout&lt;&lt; dp[v][w]&lt;&lt; endl; return 0;&#125; 小结 事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。 练习 acwing模板题——二维费用的背包问题 P06: 分组背包问题 题目 有NNN件物品和一个容量为VVV的背包。第iii件物品的费用是c[i]c[i]c[i]，价值是w[i]w[i]w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 算法 这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]f[k][v]f[k][v]表示前kkk组物品花费费用vvv能取得的最大权值，则有f[k][v]=max\\{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组\\}。 使用一维数组的伪代码如下： 1234for 所有的组k for v=V..0 for 所有的i属于组k f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; 注意这里的三层循环的顺序，“for v=V…0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。 另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。 代码实现 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e2 + 5;//物品最大数量const int maxv = 1e2 + 5;//背包最大体积int dp[maxv];//背包int volume[maxn], value[maxn];//每个物品的体积和价值int n, v;//物品组数、背包体积//分组背包 物品被划分为若干组，每组最多选一件void group_park(int n, int vol) &#123;//物品组数、背包最大容量 for (int k = 1; k &lt;= n; k++) &#123; int t;//每组的个数 cin&gt;&gt; t; for (int i = 1; i &lt;= t; i++) &#123; cin&gt;&gt; volume[i]&gt;&gt; value[i]; &#125; //从前k组中选 for (int j = vol; j &gt;= 0; j--) &#123; for (int l = 1; l &lt;= t; l++) &#123; if (volume[l] &lt;= j) &#123; dp[j] = max(dp[j], dp[j - volume[l]] + value[l]); &#125; &#125; &#125; &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v; group_park(n, v); cout&lt;&lt; dp[v]&lt;&lt; endl; return 0;&#125; 小结 分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。 练习 acwing模板题——分组背包问题 牛客——xinjun与阴阳师 * P07: 有依赖的背包问题 简化的问题 这种背包问题的物品间存在某种“依赖”的关系。也就是说，iii依赖于jjj，表示若选物品iii，则必须选物品jjj。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 算法 这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有nnn个附件，则策略有2n+12^n+12​n​​+1个，为指数级） 考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于 P06 中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 再考虑P06中的一句话： 可以对每组中的物品应用P02中“一个简单有效的优化”。 这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件iii的“附件集合”先进行一次01背包，得到费用依次为0..V−c[i]0..V-c[i]0..V−c[i]所有这些值时相应的最大价值f′[0..V−c[i]]f&#x27;[0..V-c[i]]f​′​​[0..V−c[i]]。那么这个主件及它的附件集合相当于V−c[i]+1V-c[i]+1V−c[i]+1个物品的物品组，其中费用为c[i]+kc[i]+kc[i]+k的物品的价值为f′[k]+w[i]f&#x27;[k]+w[i]f​′​​[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件iii转化为V−c[i]+1V-c[i]+1V−c[i]+1个物品的物品组，就可以直接应用P06的算法解决问题了。 较一般的问题 更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。 解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 具体思路 dfs在遍历到 xxx 结点时，先考虑一定选上根节点 xxx ，因此初始化 f[x][v[x]...m]=w[x]f[x][v[x]...m] = w[x]f[x][v[x]...m]=w[x] 在分组背包部分： jjj 的范围 $[ m , v[x] ] 小于v[x]则没有意义因为连根结点都放不下； k的范围 [ 0 , j-v[x] ]，当大于j-v[x]$时分给该子树的容量过多，剩余的容量连根节点的物品都放不下了； 代码实现 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;//物品最大数量const int maxv = 1e2 + 5;//背包最大体积int dp[maxn][maxv];//dp[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值vector&lt;int&gt; tree[maxn];//树，存放依赖关系int volume[maxn], value[maxn];//每个物品的体积和价值int n, v, root;//总物品数、背包容量、树根结点//有依赖的背包void dfs(int x) &#123; for (int i = volume[x]; i &lt;= v; i++) dp[x][i] = value[x];//点x必须选，所以初始化dp[x][value[x] ~ v]= value[x] for (int i = 0; i &lt; tree[x].size(); i++) &#123; int son = tree[x][i]; dfs(son); for (int j = v; j &gt;= volume[x]; j--) &#123;//j的范围为value[x]~v, 小于value[x]无法选择以x为子树的物品 for (int k = 0; k &lt;= j - volume[x]; k++) &#123;//分给子树son的空间不能大于j-value[x],不然都无法选根物品x dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[son][k]); &#125; &#125; &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v; for (int i = 1; i &lt;= n; i++) &#123; int fa; cin&gt;&gt; volume[i]&gt;&gt; value[i]&gt;&gt; fa; if (fa == -1) root = i; else tree[fa].push_back(i); &#125; dfs(root); cout&lt;&lt; dp[root][v]; return 0;&#125; 小结 NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。 我想说：失败不是什么丢人的事情，从失败中全无收获才是。 练习 acwing模板题——有依赖的背包问题 * P08: 泛化物品 题目 算法 代码实现 12 小结 练习 P09: 背包问题问法的变化 输出方案 输出字典序最小的最优方案 这里“字典序最小”的意思是1...N1...N1...N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。 题目要求输出字典序最小的解，假设存在一个包含第1个物品的最优解，为了确保字典序最小那么我们必然要选第一个。那么问题就转化成从2～N这些物品中找到最优解。之前的f(i,j)f(i,j)f(i,j)记录的都是前iii个物品总容量为jjj的最优解，那么我们现在将f(i,j)f(i,j)f(i,j)定义为从第iii个元素到最后一个元素总容量为jjj的最优解。接下来考虑状态转移： f(i,j)=max\\{f(i+1,j),f(i+1,j−v[i])+w[i]\\} 两种情况，第一种是不选第iii个物品，那么最优解等同于从第i+1i+1i+1个物品到最后一个元素总容量为jjj的最优解；第二种是选了第iii个物品，那么最优解等于当前物品的价值w[i]w[i]w[i]加上从第i+1i+1i+1个物品到最后一个元素总容量为j−v[i]的最优解。 计算完状态表示后，考虑如何的到最小字典序的解。首先f(1,m)f(1,m)f(1,m)肯定是最大价值，那么我们便开始考虑能否选取第1个物品呢。 如果f(1,m)=f(2,m−v[1])+w[1]，说明选取了第1个物品可以得到最优解。 如果f(1,m)=f(2,m)f(1,m)=f(2,m)f(1,m)=f(2,m)，说明不选取第一个物品才能得到最优解。 如果f(1,m)=f(2,m)=f(2,m−v[1])+w[1]，说明选不选都可以得到最优解，但是为了考虑字典序最小，我们也需要选取该物品。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;//物品最大数量const int maxv = 1e3 + 5;//背包最大体积int dp[maxn][maxv];//从第i个元素到最后一个元素总容量为j的最优解int volume[maxn], value[maxn];//每个物品的体积和价值int n, v;//总物品数、背包体积//01背包 每种物品仅有一件，可以选择放或不放void optimal_park(int val, int vol, int i) &#123; for (int j = 0; j &lt;= v; j++) &#123; dp[i][j] = dp[i + 1][j]; if(j &gt;= vol) dp[i][j] = max(dp[i][j], dp[i + 1][j - vol] + val); &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt; volume[i]&gt;&gt; value[i]; &#125; for (int i = n; i &gt;= 1; i--) &#123; optimal_park(value[i], volume[i], i); &#125; //输出 int cur_v = v; for (int i = 1 ; i &lt;= n ; i++) &#123; if (i == n &amp;&amp; cur_v &gt;= volume[i]) &#123;//如果是最后一个元素，特判一下，防止越界即可 cout&lt;&lt; i; break; &#125; if (cur_v &lt;= 0) break; //判断下标是否越界 if (cur_v - volume[i]&gt;=0 &amp;&amp; dp[i][cur_v] == dp[i + 1][cur_v - volume[i]] + value[i]) &#123; cout&lt;&lt; i&lt;&lt; \" \"; cur_v = cur_v - volume[i];//选了第i个物品，剩余容量就要减小。 &#125; &#125; return 0;&#125; 求方案总数 最优方案的总数 这里的最优方案是指物品总价值最大的方案。以01背包为例。 时间复杂度 O(nm)O(nm)O(nm) 定义两个数组：f[maxv]f[maxv]f[maxv]，cnt[maxv]cnt[maxv]cnt[maxv]：f[i]f[i]f[i] 用来存储背包容积为 iii 时的最佳方案的总价值，cnt[i]cnt[i]cnt[i]为背包容积为 iii 时总价值为最佳的方案数。 先初始化所有的 cnt[i]cnt[i]cnt[i] 为 1，因为背包里什么也不装也是一种方案。 外层循环 nnn 次，每次读入新物品的 v,wv,wv,w 求出装新物品时的总价值，与不装新物品时作对比 如果装新物品的方案总价值更大，那么用 f[j−v]+w 来更新 f[j]f[j]f[j]，用 cnt[j−v] 更新 cnt[j]cnt[j]cnt[j] 如果总价值相等，那么最大价值的方案数就多了 cnt[j−v] 种。 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;//物品最大数量const int maxv = 1e3 + 5;//背包最大体积const int mod = 1e9 + 7;int dp[maxv], cnt[maxv];//背包，最优方案总数int volume[maxn], value[maxn];//每个物品的体积和价值int n, v;//总物品数、背包体积//01背包 求解最优方案总数void optimal_sum_park(int val, int vol) &#123; for (int j = v; j &gt;= vol; j--) &#123; int tmp = dp[j - vol] + val; if (tmp &gt; dp[j]) &#123; dp[j] = tmp; cnt[j] = cnt[j - vol]; &#125; else if (tmp == dp[j]) &#123; cnt[j] = (cnt[j] + cnt[j - vol]) % mod; &#125; &#125;&#125;int main() &#123; cin&gt;&gt; n&gt;&gt; v; for (int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt; volume[i]&gt;&gt; value[i]; &#125; for (int i = 0; i &lt;= v; i++) &#123; cnt[i] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; optimal_sum_park(value[i], volume[i]); &#125; cout&lt;&lt; cnt[v]&lt;&lt; endl; return 0;&#125; 小结 显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。 触类旁通、举一反三，应该也是一个OIer应有的品质吧。 练习 acwing模板题——背包问题求方案数","categories":[{"name":"09-算法","slug":"09-算法","permalink":"https://dragonliu2021.github.io/categories/09-算法/"}],"tags":[]},{"title":"最小生成树","slug":"最小生成树","date":"2022-04-19T05:28:41.000Z","updated":"2022-04-19T05:29:10.998Z","comments":true,"path":"2022/04/19/最小生成树/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/最小生成树/","excerpt":"","text":"1 简介 给定一个无向图，如果它任意两个顶点都联通并且是一棵树，那么我们就称之为生成树(Spanning Tree)。如果是带权值的无向图，那么权值之和最小的生成树，我们就称之为最小生成树(MST, Minimum Spanning Tree)。 常见求解最小生成树的算法有Kruskal算法和Prim算法，两者都是运用贪心的思路。两者区别：Prim在稠密图中比Kruskal优，在稀疏图(一般我们认为满足E&lt;V∗(V−1)/4E &lt; V*(V-1)/4E&lt;V∗(V−1)/4)中比Kruskal劣；Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。 注意： 最小生成树可能有多个，但边的权值之和总是唯一且最小的 最小生成树的边数=顶点数-1。砍掉一条则不连通，增加一条边则会出现回路 如果一个连通图本身就是一棵树，则其最小生成树就是它本身 只有连通图才有生成树，非连通图只有生成森林 2 Kruskal算法 Kruskal算法是基于贪心的思想得到的。首先我们把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合（两点是否连通），那么就将它们合并，直到所有的点都属于同一个集合为止（所有结点连通）。 时间复杂度：Kruskal算法每次要从都要从剩余的边中选取一个最小的边。通常我们要先对边按权值从小到大排序，这一步的时间复杂度为O(ElogE)O(ElogE)O(ElogE)。Kruskal算法的实现通常使用并查集，来快速判断两个顶点是否属于同一个集合。最坏的情况可能要枚举完所有的边，此时要循环EEE次，所以这一步的时间复杂度为O(E*α(V))，其中α为Ackermann函数，其增长非常慢，我们可以视为常数。所以Kruskal算法的时间复杂度为O(ElogE)O(ElogE)O(ElogE)。 参考：https://blog.csdn.net/luomingjun12315/article/details/47700237/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int maxn = 1e5 + 5;const int maxv = 5e5 + 5;const int inf = 0x7fffffff;int n, v; // n是点数，v是边数struct Edge &#123;// 存储边 int a, b, w; bool operator&lt; (const Edge &amp;W)const &#123; return w &lt; W.w; &#125;&#125;edges[maxv];int node[maxn];//并查集的父节点数组int Rank[maxn];//树的高度//初始化void init(int n) &#123; for (int i=0; i&lt;=n; i++) &#123; node[i] = i; Rank[i] = 1; &#125;&#125;//路径压缩//查找当前元素所在树的根节点(代表元素)int find(int x) &#123; if (x == node[x]) return x; return node[x] = find(node[x]);//在第一次查找时，将节点直连到根节点&#125;//按秩合并//合并x和y所在的集合void merge(int x, int y) &#123; int root_x = find(x);//找到根节点 int root_y = find(y); if (root_x == root_y)//两者根节点相同 return ; //判断两棵树的高度，然后在决定谁为子树 if (Rank[root_x] &lt; Rank[root_y]) node[root_x] = root_y;//将x的根节点接到y的根节点下 else &#123; node[root_y] = root_x;//将y的根节点与x的根节点下 if (Rank[root_x] == Rank[root_y])//树的高度相同 Rank[root_x]++;//root_x树高度+1 &#125;&#125;//判断xy是否属于一个集合bool same(int x, int y) &#123; return find(x) == find(y);&#125;int kruskal() &#123; sort(edges, edges + v); init(n); // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; v; i ++ ) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) &#123;// 如果两个连通块不连通， merge(a, b);//则将这两个连通块合并 res += w; cnt ++ ; &#125; &#125; if (cnt &lt; n - 1) return inf;//原图不连通 return res;&#125; 3 Prim算法 思想： 从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。 时间复杂度： 最小边、权的数据结构 时间复杂度（总计） 邻接矩阵、搜索 O(V2)O(V^2)O(V​2​​) 二叉堆、邻接表 O((V+E)log(V))=O(Elog(V))O((V + E) log(V)) = O(E log(V))O((V+E)log(V))=O(Elog(V)) 斐波那契堆、邻接表 O(E+Vlog(V))O(E + V log(V))O(E+Vlog(V)) 流程： 输入：一个加权连通图，其中顶点集合为VVV，边集合为EEE 输出：使用集合VnewVnewVnew和EnewEnewEnew来描述所得到的最小生成树 从单一顶点开始，Prim算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。 初始化：Vnew=xVnew = {x}Vnew=x，其中xxx为集合VVV中的任一节点(起始点)，Enew={}Enew = \\{\\}Enew={}； 重复下列操作，直到Vnew=VVnew = VVnew=V: 在集合EEE中选取权值最小的边(u,v)(u, v)(u,v)，其中uuu为集合VnewVnewVnew中的元素，而vvv则是VVV中没有加入VnewVnewVnew的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）； 将vvv加入集合VnewVnewVnew中，将(u,v)(u, v)(u,v)加入集合EnewEnewEnew中。 参考：https://blog.csdn.net/luomingjun12315/article/details/47859993 12345678910111213141516171819202122232425262728293031const int maxn = 105;const int inf = 0x3f3f3f3f;int n; // n表示点数int g[maxn][maxn]; // 邻接矩阵，存储所有边，编号从1开始 int dist[maxn]; // 存储其他点到当前最小生成树的距离bool st[maxn]; // 存储每个点是否已经在生成树中// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim() &#123; memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) &#123; //寻找代价最小的新顶点 int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; //原图不连通 if (i &amp;&amp; dist[t] == inf) return inf; //加点 if (i) res += dist[t]; st[t] = true; //更新dist for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); &#125; return res;&#125; 练习 牛客——道路建设 牛客——挖沟","categories":[{"name":"08-图论","slug":"08-图论","permalink":"https://dragonliu2021.github.io/categories/08-图论/"}],"tags":[]},{"title":"最短路","slug":"最短路","date":"2022-04-19T05:28:04.000Z","updated":"2022-04-19T05:28:20.611Z","comments":true,"path":"2022/04/19/最短路/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/最短路/","excerpt":"","text":"1 简介 最短路问题分为两类：单源最短路和多源最短路。前者只需要求一个固定的起点到各个顶点的最短路径，后者则要求得出任意两个顶点之间的最短路径。 单源 Dijkstra算法： 优点：时间复杂度稳定O(n2)O(n^2)O(n​2​​)，堆优化能达到O(ElogE)O(ElogE)O(ElogE)；也可解决多源最短路，总的时间复杂度也是O(n3)O(n^3)O(n​3​​) 缺点：不能处理负边 单源 Bellman-Ford算法： 优点：其优于Dijkstra算法的方面是边的权值可以为负数、实现简单 缺点：时间复杂度过高，高达O(V∗E)O(V*E)O(V∗E)；但算法可以进行若干种优化，提高了效率。 单源 SPFA算法： 优点：快于Bellman-Ford，据说随机数据下期望时间复杂度是O(m+nlogn)O(m+nlogn)O(m+nlogn) 缺点：时间复杂度不稳定，最坏情况可以被卡成Bellman-Ford，也就是O(V∗E)O(V*E)O(V∗E) 全源 Floyd算法： 优点：算法简洁，可以解决负权图 缺点：时间复杂度为O(n3)O(n^3)O(n​3​​)，空间复杂度为O(n2)O(n^2)O(n​2​​)，都比较高，所以只适用于数据规模较小的情形；不能解决负环图 全源 Johnson算法： 优点：相对于Floyd算法时间复杂度低，O(nmlogm)O(nmlogm)O(nmlogm)； 缺点：无负环图、算法较繁琐 BFS算法： 优点： 缺点：只能解决无权图 2 单源 Dijkstra算法 贪心的思想，不断取出离顶点最近而没有被访问过的点，松弛它和它能到达的所有点。 对于每个顶点v∈V，都设置一个属性d[v]，用来描述从源点s到v的最短路径上权值的上界，称为最短路径估计（shortest-pathestimate）。 π[v]代表S到v的当前最短路径中v点之前的一个点的编号,我们用下面的Θ(V)时间的过程来对最短路径估计和前趋进行初始化。 在松弛一条边(u,v)的过程中，要测试是否可以通过u，对迄今找到的v的最短路径进行改进；如果可以改进的话，则更新d[v]和π[v]。一次松弛操作可以减小最短路径估计的值d[v]，并更新v的前趋域π[v](S到v的当前最短路径中v点之前的一个点的编号)。 打印路径：只需要用一个pre[]数组存储每个点的父节点即可。（单源最短路的起点是固定的，所以每条路有且仅有一个祖先节点，一步步溯源上去的路径是唯一的。相反，这里不能存子节点，因为从源点下去，有很多条最短路径） 参考：https://zhuanlan.zhihu.com/p/96621396 朴素Dijkstra：时间复杂度是 O(n2+m)O(n^2+m)O(n​2​​+m), nnn 表示点数，mmm 表示边数 12345678910111213141516171819202122232425262728const int maxn = 5e2 + 5;int g[maxn][maxn]; // 存储每条边int dist[maxn]; // 存储1号点到每个点的最短距离bool st[maxn]; // 存储每个点的最短路是否已经确定int n;//点数 // 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i ++ ) &#123; int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125; 堆优化Dijkstra：时间复杂度 O(mlogn)O(mlogn)O(mlogn), nnn 表示点数，mmm 表示边数 123456789101112131415161718192021222324252627282930313233343536373839404142const int maxn = 1.5e5 + 5;typedef pair&lt;int, int&gt; PII;int n; // 点的数量int h[maxn], w[maxn], e[maxn], ne[maxn], idx; // 邻接表存储所有边int dist[maxn]; // 存储所有点到1号点的距离bool st[maxn]; // 存储每个点的最短距离是否已确定//加边void add(int x, int y, int c) &#123; w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++;&#125;// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push(&#123;0, 1&#125;); // first存储距离，second存储节点编号 while (heap.size()) &#123; auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) &#123; int j = e[i]; if (dist[j] &gt; distance + w[i]) &#123; dist[j] = distance + w[i]; heap.push(&#123;dist[j], j&#125;); &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125; 3 单源 Bellman-Ford算法 一维数组dist[]来存储每个点到起点的距离，初始化dist[S] = 0，其他初始化为INF。 找到从起点到某个点的最短路，设起点为S，终点为D，那这条最短路一定是S−&gt;P1−&gt;P2−&gt;...−&gt;DS-&gt;P_1-&gt;P_2-&gt;...-&gt;DS−&gt;P​1​​−&gt;P​2​​−&gt;...−&gt;D的形式，假设没有负权环，那这条路径上的点的总个数一定不大于n。 定义对点x, y的松弛操作是： 1dist[y] = min(dist[y], dist[x] + e[x][y]);//这里的e[x][y]表示x、y之间的距离，具体形式可能根据存图方法不同而改变 松弛操作就相当于考察能否经由x点使起点到y点的距离变短。 所以要找到最短路，只需要进行以下步骤： 先松弛SSS, P1P_1P​1​​，此时dist[P1]dist[P_1]dist[P​1​​]必然等于e[S][P1]e[S][P_1]e[S][P​1​​] 再松弛P1,P2P_1, P_2P​1​​,P​2​​，因为S−&gt;P1−&gt;P2S-&gt;P_1-&gt;P_2S−&gt;P​1​​−&gt;P​2​​是最短路的一部分，最短路的子路也是最短路（这是显然的），所以dist[P2]dist[P_2]dist[P​2​​]不可能小于dist[P1]+e[P1][P2]dist[P_1]+e[P_1][P_2]dist[P​1​​]+e[P​1​​][P​2​​]，因此它会被更新为dist[P1]+e[P1][P2]dist[P1]+e[P1][P2]dist[P1]+e[P1][P2]，即e[S][P1]+e[P1][P2]e[S][P1]+e[P1][P2]e[S][P1]+e[P1][P2]。 再松弛P2,P3P2, P3P2,P3，……以此类推，最终dist[D]dist[D]dist[D]必然等于e[S][P1]+e[P1][P2]+...e[S][P1]+e[P1][P2]+...e[S][P1]+e[P1][P2]+...，这恰好就是最短路径。 把所有边松弛n-1遍！ https://zhuanlan.zhihu.com/p/96621396 https://blog.csdn.net/luomingjun12315/article/details/50377525 4 单源 SPFA算法 SPFA算法，也就是队列优化的Bellman-Ford算法，维护一个队列。 5 全源 Floyd算法 求出每一对顶点之间的最短路径。Floyd本质上是一个动态规划的思想，每一次循环更新经由k点，i到j的最短路径。 123456789101112131415161718192021// 算法结束后，d[a][b]表示a到b的最短距离，path存放路径信息void floyd() &#123; // 初始化： for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = inf; //memset(path, -1, sizeof path); //dp for (int k = 1; k &lt;= n; k ++ ) &#123;//考虑以k为中转点 for (int i = 1; i &lt;= n; i ++ ) &#123; for (int j = 1; j &lt;= n; j ++ ) &#123; if (d[i][j] &gt; d[i][k] + d[k][j]) &#123;//以k为中转点的路径更短 d[i][j] = d[i][k] + d[k][j];//更新最短路径长度 //path[i][j] = k;//中转点 &#125; &#125; &#125; &#125; &#125; 6 全源 Johnson算法 7 BFS算法 该算法求单源最短路径只适用于无权图，或所有边的权值都相同的图。 练习 acwing模板题目——Dijkstra求最短路 I Dijkstra求最短路 II","categories":[{"name":"08-图论","slug":"08-图论","permalink":"https://dragonliu2021.github.io/categories/08-图论/"}],"tags":[]},{"title":"拓扑排序","slug":"拓扑排序","date":"2022-04-19T05:26:31.000Z","updated":"2022-04-19T05:27:09.000Z","comments":true,"path":"2022/04/19/拓扑排序/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/拓扑排序/","excerpt":"","text":"简介 有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图（Directed Acyclic Graph） AOV网（Activity On Vertex Network，用顶点表示活动的网）：用DAG表示一个工程，顶点表示活动，有向边&lt;Vi,Vj&gt;&lt;V_i,V_j&gt;&lt;V​i​​,V​j​​&gt;表示活动ViV_iV​i​​必须先于VjV_jV​j​​进行。 拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列，且该序列必须满足下面两个条件： 每个顶点出现且只出现一次。 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。 实现： 从AOV网中选择一个没有前驱（入度为0）的顶点并输出； 从网中删除该顶点和所有以它为起点的有向边； 重复1和2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止（说明有回路）。 逆拓扑序： 从AOV网中选择一个没有后继（出度为0）的顶点并输出； 从网中删除该顶点和所有以它为终点的有向边； 重复1和2直到当前的AOV网为空。 思路： 用一种容器（比如栈，队列，集合）维护当前所有入度为0的点。 每次从容器中取出一个点，删掉他和他的出边，这可能导致一些点入度为0，将新的入度为0的点加入容器。 代码 邻接表：时间复杂度 O(n+m)O(n+m)O(n+m), nnn 表示点数，mmm 表示边数 邻接矩阵：时间复杂度 O(n2)O(n^2)O(n​2​​) 也可以使用dfs实现 12345678910111213141516171819202122232425262728293031323334353637383940const int maxn = 1e5 + 5;const int maxe = 2e5 + 5;int n; // 点的数量int h[maxn], e[maxe], ne[maxe], idx; // 邻接表存储所有边int d[maxn];//每个点的入度 int print[maxn];//拓扑序列 //加边void add(int x, int y) &#123; e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++; d[y]++;//入度 &#125;//拓扑排序 bool topsort() &#123; stack&lt;int&gt; s;//存储入度为0的点 // d[i] 存储点i的入度 for (int i = 1; i &lt;= n; i ++ ) if (!d[i])//将所有入度为0的点入栈 s.push(i); int cnt = 0;//记录当前已经输出的顶点数 while (!s.empty()) &#123;//栈不空，存在入度为0的顶点 int t = s.top(); s.pop(); print[cnt++] = t; for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (-- d[j] == 0) s.push(j); &#125; &#125; // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return cnt == n;&#125; 练习","categories":[{"name":"08-图论","slug":"08-图论","permalink":"https://dragonliu2021.github.io/categories/08-图论/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://dragonliu2021.github.io/tags/拓扑排序/"}]},{"title":"欧拉路","slug":"欧拉路","date":"2022-04-19T05:24:52.000Z","updated":"2022-04-19T05:25:55.930Z","comments":true,"path":"2022/04/19/欧拉路/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/欧拉路/","excerpt":"","text":"1 基础概念 欧拉回路：每条边只经过一次，而且回到起点 欧拉路径：每条边只经过一次，不要求回到起点 欧拉回路判断： 无向图：连通(不考虑度为 0 的点)，没有奇度顶点 有向图：强连通，每个顶点出度等于入度 混合图(有无向边和有向边)：首先是基图连通(不考虑度为 0 的点)，然后需要借助网络流判定。 首先给原图中的每条无向边随便指定一个方向（称为初始定向），将原图改为有向图 G’，然后的任务就是改变 G’ 中某些边的方向（当然是无向边转化来的，原混合图中的有向边不能动）使其满足每个点的入度等于出度。 设 D[i]D[i]D[i] 为 G’ 中 (点 iii 的出度 - 点 $i $的入度）。可以发现，在改变 G’ 中边的方向的过程中，任何点的 DDD 值的奇偶性都不会发生改变（设将边 &lt;i,j&gt;&lt;i, j&gt;&lt;i,j&gt; 改为 &lt;j,i&gt;&lt;j, i&gt;&lt;j,i&gt;，则 $i 入度加 1 出度减 1，j$ 入度减 1 出度加 1，两者之差加 2 或减 2，奇偶性不变）！而最终要求的是每个点的入度等于出度，即每个点的 DDD 值都为 0，是偶数，故可得：若初始定向得到的 G’ 中任意一个点的DDD值是奇数，那么原图中一定不存在欧拉环！ 若初始 DDD 值都是偶数，则将 G’ 改装成网络：设立源点 SSS 和汇点 TTT，对于每个 D[i]&gt;0D[i]&gt;0D[i]&gt;0 的点iii，连边 &lt;S,i&gt;&lt;S, i&gt;&lt;S,i&gt;，容量为 D[i]/2D[i]/2D[i]/2；对于每个 D[j]&lt;0D[j]&lt;0D[j]&lt;0 的点 jjj，连边 &lt;j,T&gt;&lt;j, T&gt;&lt;j,T&gt;，容量为 −D[j]/2-D[j]/2−D[j]/2； G’中的每条边在网络中仍保留，容量为 1（表示该边最多只能被改变方向一次）。求这个网络的最大流，若 SSS 引出的所有边均满流，则原混合图是欧拉图，将网络中所有流量为 1 的中间边（就是不与 SSS 或 TTT关联的边）在 G’ 中改变方向，形成的新图 G” 一定是有向欧拉图；若 SSS 引出的边中有的没有满流，则原混合图不是欧拉图。 欧拉路径的判断： 无向图：连通(不考虑度为 0 的点)，没有奇度顶点或恰有两个奇度顶点 有向图：基图连通(把边当成无向边，同样不考虑度为 0 的点)，每个顶点出度等于入度或 者有且仅有一个点的出度比入度多 1，有且仅有一个点的出度比入度少 1，其余出度等于入 度。 混合图：如果存在欧拉回路，一定存在欧拉路径了。否则如果有且仅有两个点的（出度 -入 度）是奇数，那么给这个两个点加边，判断是否存在欧拉回路。 https://blog.csdn.net/richenyunqi/article/details/80382450/ 欧拉路径模板 1 递归 12345678910111213141516171819202122232425262728293031323334353637383940414243//无向图的欧拉路径#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;vector&lt;int&gt;graph[maxn],path;//图、欧拉路径的倒序int N, M;//顶点数、边数bool visit[maxn][maxn];//表示边是否已被访问//顶点v的度数是否为奇数bool f(vector&lt;int&gt;&amp;v)&#123; return v.size()%2==1;&#125;//深度优先遍历void DFS(int v)&#123; for(int i=0;i&lt;graph[v].size();++i)&#123;//遍历该点能到达的结点 int w=graph[v][i]; if(!visit[v][w])&#123;//该边没有被访问过 visit[v][w]=visit[w][v]=true;//该边已被访问 DFS(w);//递归遍历 &#125; &#125; path.push_back(v);//加入欧拉路径中&#125;int main()&#123; scanf(\"%d%d\",&amp;N,&amp;M);//输入点数、边数 for(int i=0;i&lt;M;++i)&#123;//输入边，无向图 int a,b; scanf(\"%d%d\",&amp;a,&amp;b); graph[a].push_back(b); graph[b].push_back(a); &#125; for(int i=1;i&lt;=N;++i)//排序、题目要求输出字典序最小的一种方案 sort(graph[i].begin(),graph[i].end()); DFS(1); int k=count_if(graph+1,graph+N+1,f);//度数为奇数的顶点个数 //连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点 if(path.size()==M+1&amp;&amp;(k==0||(k==2&amp;&amp;f(graph[1])))) for(int i=path.size()-1;i&gt;=0;--i)//反向输出路径 printf(\"%d \",path[i]); else printf(\"-1\"); return 0;&#125; 2 非递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//无向图的欧拉路径#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+5;vector&lt;int&gt;graph[maxn],path;//图、欧拉路径的倒序int N, M;//顶点数、边数bool visit[maxn][maxn];//表示边是否已被访问//顶点v的度数是否为奇数bool f(vector&lt;int&gt;&amp;v)&#123; return v.size()%2==1;&#125;int main()&#123; scanf(\"%d%d\",&amp;N,&amp;M);//输入点数、边数 for(int i=0;i&lt;M;++i)&#123;//输入边，无向图 int a,b; scanf(\"%d%d\",&amp;a,&amp;b); graph[a].push_back(b); graph[b].push_back(a); &#125; for(int i=1;i&lt;=N;++i)//排序、题目要求输出字典序最小的一种方案 sort(graph[i].begin(),graph[i].end()); stack&lt;int&gt;s; s.push(1);//1号顶点(起点)入栈 while(!s.empty())&#123; int v=s.top(),i; for(i=0;i&lt;graph[v].size();++i)&#123;//遍历该点能到达的结点 int w=graph[v][i]; if(!visit[v][w])&#123;//该边没有被访问过 s.push(w);//顶点w入栈 visit[v][w]=visit[w][v]=true;//该边已被访问 break;//跳出循环 &#125; &#125; if(i==graph[v].size())&#123;//没有还未访问的边 path.push_back(v);//顶点v加入欧拉序列 s.pop();//出栈 &#125; &#125; int k=count_if(graph+1,graph+N+1,f);//度数为奇数的顶点个数 //连通、没有奇度顶点或恰有两个奇度顶点且起点为奇度顶点 if(path.size()==M+1&amp;&amp;(k==0||(k==2&amp;&amp;f(graph[1])))) for(auto i=path.rbegin();i!=path.rend();++i)//倒序输出 printf(\"%d \",*i); else printf(\"-1\"); return 0;&#125;","categories":[{"name":"08-图论","slug":"08-图论","permalink":"https://dragonliu2021.github.io/categories/08-图论/"}],"tags":[{"name":"欧拉路","slug":"欧拉路","permalink":"https://dragonliu2021.github.io/tags/欧拉路/"}]},{"title":"关键路径","slug":"关键路径","date":"2022-04-19T05:23:37.000Z","updated":"2022-04-19T05:24:30.054Z","comments":true,"path":"2022/04/19/关键路径/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/关键路径/","excerpt":"","text":"简介 概念： AOE网（Activity On Edge Network，用顶点表示活动的网）：在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络。 在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。 从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。 完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。 性质： 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始； 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。 求解关键路径的一些定义： 事件vkv_kv​k​​的最早发生时间ve(k)ve{(k)}ve(k)——决定了所有以vkv_kv​k​​开始的活动能够开工的最早时间 活动aia_ia​i​​的最早开始时间e(i)e(i)e(i)——指该活动弧的起点所表示的事件的最早发生时间 事件vkv_kv​k​​的最迟发生时间vl(k)vl(k)vl(k)——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。 活动aia_ia​i​​的最迟开始时间l(i)l(i)l(i)——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。 活动aia_ia​i​​的时间余量d(i)=l(i)−e(i)d(i)=l(i)-e(i)d(i)=l(i)−e(i)，表示在不增加完成整个工程所需总时间的情况下，活动aia_ia​i​​可以拖延的时间 若一个活动的时间余量为零，则说明该活动必须要如期完成，d(i)=0d(i)=0d(i)=0的活动aia_ia​i​​是关键活动；由关键活动组成的路径就是关键路径。 求解关键路径的步骤： 求所有事件的最早发生时间ve()ve()ve() 按拓扑排序序列，依次求各个顶点的 ve(k)v e(k)ve(k) : ve(v e(ve( 源点 )=0)=0)=0 v e(k)=\\operatorname{Max}\\left\\{v \\mathrm{e}(j)+\\operatorname{Weight}\\left(v_{j}, v_{k}\\right)\\right\\}, \\quad v_{j} 为 vkv_{k}v​k​​ 的任意前驱 求所有事件的最迟发生时间vl()vl()vl() 按逆拓扑排序序列，依次求各个顶点的 v l(\\boldsymbol{k}) : vl(v l(vl( 汇点 )=v e( 汇点) v l(k)=\\operatorname{Min}\\left\\{v l(j)-\\operatorname{Weight}\\left(v_{k}, v_{j}\\right)\\right\\}, v_{j} 为 vkv_{k}v​k​​ 的任意后继 求所有活动的最早发生时间e()e()e() 若边 &lt;vk,vj&gt;&lt;v_{k}, v_{j}&gt;&lt;v​k​​,v​j​​&gt; 表示活动 aia_{i}a​i​​, 则有 e(i)=ve(k)e(i)=v e(k)e(i)=ve(k) 求所有活动的最迟发生时间l()l()l() 若边 &lt;vk,vj&gt;&lt;v_{k}, v_{j}&gt;&lt;v​k​​,v​j​​&gt; 表示活动 aia_{i}a​i​​, 则有 l(i)=vl(j)−l(i)=v l(j)-l(i)=vl(j)− Weight (vk,vj)\\left(v_{k}, v_{j}\\right)(v​k​​,v​j​​) 求所有活动的时间余量d()d()d() d(i)=l(i)−e(i)d(i)=l(i)-e(i)d(i)=l(i)−e(i) 关键活动、关键路径的特性： 若关键活动耗时增加，则整个工程的工期将增长 缩短关键活动的时间，可以缩短整个工程的工期 当缩短到一定程度时，关键活动可能会变成非关键活动 可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。","categories":[{"name":"08-图论","slug":"08-图论","permalink":"https://dragonliu2021.github.io/categories/08-图论/"}],"tags":[{"name":"关键路径","slug":"关键路径","permalink":"https://dragonliu2021.github.io/tags/关键路径/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2022-04-19T05:21:19.000Z","updated":"2022-04-19T05:22:44.656Z","comments":true,"path":"2022/04/19/KMP算法/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/KMP算法/","excerpt":"","text":"1 算法思想 1.1 思路 解决问题：当主串中第 i 个字符与模式中第 j 个字符失配（即比较不相等）时，主串中第 i 个字符（i 指针不回溯）应与模式中哪个字符再比较。 next[j]next[j]next[j]：模式中第 j 个字符失配时，在模式中重新与主串比较的字符位置（最长公共前后缀长度+1，下标从 1 开始） \\text { next }[j]=\\left\\{\\begin{array}{ll} 0 & \\text { 当 } j=1 \\text { 时 } \\\\ \\operatorname{Max}\\left\\{k \\mid 1","categories":[{"name":"06-字符串","slug":"06-字符串","permalink":"https://dragonliu2021.github.io/categories/06-字符串/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://dragonliu2021.github.io/tags/KMP/"}]},{"title":"搜索","slug":"搜索","date":"2022-04-19T05:18:42.000Z","updated":"2022-04-19T05:20:38.031Z","comments":true,"path":"2022/04/19/搜索/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/搜索/","excerpt":"","text":"1 DFS 123456789101112131415161718192021int check(参数)&#123; if(满足条件) return 1; return 0;&#125; void dfs(int step)&#123; 判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（回溯的时候要用到） &#125;&#125; 2 BFS BFS使用队列，把每个还没有搜索到的点一次放入队列，然后再弹出队列的头部元素当做当前遍历点。当不需要确定当前遍历层数时： 123456queue.push(s)//压入起点，初始队列可能有多个起点while queue 不空： cur = queue.pop() for 节点 in cur的所有相邻节点： if 该节点有效且未访问过： queue.push(该节点) 当需要确定遍历层数时，这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在开始遍历新的一层时，队列中有多少个元素，即有多少个点需要向前走一步。 1234567891011queue.push(s)//压入起点level = 0while queue 不空： size = queue.size() while (size --) &#123; cur = queue.pop() for 节点 in cur的所有相邻节点： if 该节点有效且未被访问过： queue.push(该节点) &#125; level ++ 3 二分 1234567891011121314151617// 在[l, h)范围内查找值v(l&gt;=0),返回下标,假设a数组已经按从⼩到⼤排序,失败返回-1int bs(int a[], int l, int h, int v)&#123; int m; while (l &lt; h)&#123; m = (l + h) &gt;&gt; 1; if (a[m] == v)&#123; return m; &#125; if (a[m] &lt; v)&#123; l = m + 1; &#125; else&#123; h = m; &#125; &#125; return -1;&#125; 4 双向搜索 起点是给出的，终点也是已知的，需要确定能否从起点到达终点，如果可以，需要多少步。 如果我们用常规的搜索方法，从起点开始往下搜，那得到的解答树可能非常庞大，这样漫无目的的搜索就像大海捞针。让我们切换一下思路，既然终点是已知的，我们何必让它闲着呢？我们完全可以分别从起点和终点出发，看它们能否相遇。 如果原本的解答树规模是 ，使用双向搜索后，规模立刻缩小到了约 ，当 较大时优化非常可观。 双向搜索主要有两种，双向BFS和双向迭代加深。 4.1 双向BFS 与普通的BFS不同，双向BFS维护两个而不是一个队列，然后轮流拓展两个队列。同时，用数组（如果状态可以被表示为较小的整数）或哈希表记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束。 12345678910111213141516171819queue&lt;T&gt; Q[3]; // T要替换为用来表示状态的类型，可能为int，string还有bitset等bool found = false;Q[1].push(st); // st为起始状态Q[2].push(ed); // ed为终止状态for (int d = 0; d &lt; D + 2; ++d) // D为最大深度，最后答案为d-1&#123; int dir = (d &amp; 1) + 1, sz = Q[dir].size(); // 记录一下当前的搜索方向，1为正向，2为反向 for (int i = 0; i &lt; sz; ++i) &#123; auto x = Q[dir].front(); Q[dir].pop(); if (H[x] + dir == 3) // H是数组或哈希表，若H[x]+dir==3说明两个方向都搜到过这个点 found = true; H[x] = dir; // 这里需要把当前状态能够转移到的新状态压入队列 &#125; if (found) // ...&#125; 4.2 双向迭代加深 迭代加深算法是那种，听名字非常高端，思想和实现却都很简单的算法。就是控制dfs的最大深度，如果深度超过最大深度就返回。某个深度搜完后没有得到答案便令最大深度+1，然后重新开始搜索。 这听起来好像效果跟广搜差不多啊？还重复搜索了很多次。但是，由于搜索的时间复杂度几乎完全由解答树的最后一层确定（看上面第一张图就能感悟到），所以它与BFS在时间上只有常数级别的差距，以此换来的优势是：空间占用很小，有时候方便剪枝、方便传参等。 双向迭代加深就是相应地，从两个方向迭代加深搜索。先从起点开始搜0层，再从终点开始搜0层，然后从起点开始搜1层…… 12345678910111213141516171819202122232425int D;bool found;template &lt;class T&gt;void dfs(T x, int d, int dir)&#123; if (H[x] + dir == 3) found = true; H[x] = dir; if (d == D) return; // 这里需要递归搜索当前状态能够转移到的新状态&#125;// 在main函数中...while (D &lt;= MAXD / 2) // MAXD为题中要求的最大深度&#123; dfs(st, 0, 1); // st为起始状态 if (found) // ... // 题中所给最大深度为奇数时这里要判断一下 dfs(ed, 0, 2); // ed为终止状态 if (found) // ... D++;&#125; https://zhuanlan.zhihu.com/p/119349440 5 极大极小值搜索算法 简单的对抗搜索 评估函数的返回值直接设定成题目中的评估得分即可 在博弈树搜索时，先手返回能向下递归所得的最大值，后手反之返回最小值 如果某种状态已经分出胜负或者平手，就说明该种状态就是博弈树中的叶子节点，需要计算评估得分进行返回 数据很小可以不用alpha-beta剪枝 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define rep(x,a,b) for(int x=(a);x&lt;=(b);x++)using namespace std;const int maxn=4;int a[maxn][maxn];//棋盘 int check()&#123; //计算评估分数，-2000代表还能继续进行棋局 int x=0; rep(i,0,2) rep(j,0,2) x+=(a[i][j]==0); rep(i,0,2)&#123;//A或B获胜 if(a[i][0]==1&amp;&amp;a[i][1]==1&amp;&amp;a[i][2]==1) return x+1; if(a[i][0]==2&amp;&amp;a[i][1]==2&amp;&amp;a[i][2]==2) return -x-1; if(a[0][i]==1&amp;&amp;a[1][i]==1&amp;&amp;a[2][i]==1) return x+1; if(a[0][i]==2&amp;&amp;a[1][i]==2&amp;&amp;a[2][i]==2) return -x-1; &#125; //A或B获胜 if(a[0][0]==1&amp;&amp;a[1][1]==1&amp;&amp;a[2][2]==1) return x+1; if(a[0][2]==1&amp;&amp;a[1][1]==1&amp;&amp;a[2][0]==1) return x+1; if(a[0][0]==2&amp;&amp;a[1][1]==2&amp;&amp;a[2][2]==2) return -x-1; if(a[0][2]==2&amp;&amp;a[1][1]==2&amp;&amp;a[2][0]==2) return -x-1; if(x==0) return 0;//平局 else return -2000;//棋局未结束 &#125;int dfs(int dep)&#123; //dep=0代表先手，1代表后手 int res=check(); if(res!=-2000)//棋局结束 return res;//叶子节点返回 int Res = dep==0 ? -1000:1000; rep(i,0,2) rep(j,0,2)&#123; if(!a[i][j])&#123; a[i][j] = dep==0 ? 1:2;//打标签 if( dep==0 )//先手找最大 Res = max(Res, dfs(dep^1));//按位异或实现01轮流下棋 else//后手找最小 Res = min(Res, dfs(dep^1)); a[i][j] = 0;//去标签 &#125; &#125; return Res;&#125;int main()&#123; ios::sync_with_stdio(false); int T;//测试组数 cin&gt;&gt; T; while(T--)&#123; rep(i,0,2)//输入当前棋盘 rep(j,0,2) cin&gt;&gt; a[i][j]; cout&lt;&lt; dfs(0)&lt;&lt; endl; &#125; return 0;&#125; 使用用alpha-beta剪枝： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define rep(x,a,b) for(int x=(a);x&lt;=(b);x++)using namespace std;const int maxn=4;int a[maxn][maxn];//棋盘 int check()&#123; //计算评估分数，-2000代表还能继续进行棋局 int x=0; rep(i,0,2) rep(j,0,2) x+=(a[i][j]==0); rep(i,0,2)&#123;//A或B获胜 if(a[i][0]==1&amp;&amp;a[i][1]==1&amp;&amp;a[i][2]==1) return x+1; if(a[i][0]==2&amp;&amp;a[i][1]==2&amp;&amp;a[i][2]==2) return -x-1; if(a[0][i]==1&amp;&amp;a[1][i]==1&amp;&amp;a[2][i]==1) return x+1; if(a[0][i]==2&amp;&amp;a[1][i]==2&amp;&amp;a[2][i]==2) return -x-1; &#125; //A或B获胜 if(a[0][0]==1&amp;&amp;a[1][1]==1&amp;&amp;a[2][2]==1) return x+1; if(a[0][2]==1&amp;&amp;a[1][1]==1&amp;&amp;a[2][0]==1) return x+1; if(a[0][0]==2&amp;&amp;a[1][1]==2&amp;&amp;a[2][2]==2) return -x-1; if(a[0][2]==2&amp;&amp;a[1][1]==2&amp;&amp;a[2][0]==2) return -x-1; if(x==0) return 0;//平局 else return -2000;//棋局未结束 &#125;int dfs(int dep, int lval)&#123; //dep=0代表先手，1代表后手 //lval表示如果父亲是先手就是父亲的alpha，否则是父亲的beta int res=check(); if(res!=-2000)//棋局结束 return res; if(dep==0)&#123; int alpha=-1e9;//alpha表示先手能找到的最大值 rep(i,0,2) rep(j,0,2) if(!a[i][j])&#123; a[i][j]=1; alpha=max(alpha,dfs(dep^1,alpha)); a[i][j]=0; if(alpha&gt;lval) return alpha; //如果先手能找到的最大值比后手父亲能找到的最小值还大，后手父亲就肯定不选当前的子树，直接返回进行剪枝 &#125; return alpha; &#125; else&#123; int beta=1e9;//beta表示后手能找到的最小值 rep(i,0,2) rep(j,0,2) if(!a[i][j])&#123; a[i][j]=2; beta=min(beta,dfs(dep^1,beta)); a[i][j]=0; if(beta&lt;lval) return beta; //反之同理 &#125; return beta; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); int T;//测试组数 cin&gt;&gt; T; while(T--)&#123; rep(i,0,2)//输入当前棋盘 rep(j,0,2) cin&gt;&gt; a[i][j]; cout&lt;&lt; dfs(0, 1e9)&lt;&lt; endl; &#125; return 0;&#125; 练习","categories":[{"name":"05-搜索","slug":"05-搜索","permalink":"https://dragonliu2021.github.io/categories/05-搜索/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://dragonliu2021.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://dragonliu2021.github.io/tags/BFS/"},{"name":"回溯法","slug":"回溯法","permalink":"https://dragonliu2021.github.io/tags/回溯法/"},{"name":"二分","slug":"二分","permalink":"https://dragonliu2021.github.io/tags/二分/"}]},{"title":"排序算法","slug":"排序算法","date":"2022-04-19T05:15:50.000Z","updated":"2022-04-19T05:17:44.631Z","comments":true,"path":"2022/04/19/排序算法/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/排序算法/","excerpt":"","text":"排序算法 最好时间复杂度 平均时间复杂度 最坏时间复杂度 空间复杂度 稳定性 直接插入排序 有序：O(n)O(n)O(n) O(n2)O(n^2)O(n​2​​) 逆序：O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 稳定 希尔排序 复杂度未得到证明 O(n1.3−2)O(n^{1.3-2})O(n​1.3−2​​) d=1：O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 不稳定 冒泡排序 有序：O(n)O(n)O(n) O(n2)O(n^2)O(n​2​​) 逆序：O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 稳定 快速排序 划分均匀：O(nlog2n)O(nlog_2n)O(nlog​2​​n) O(nlog2n)O(nlog_2n)O(nlog​2​​n) 有序：O(n2)O(n^2)O(n​2​​) O(log2n∼n)O(log_2n\\sim n)O(log​2​​n∼n) 不稳定 简单选择排序 O(n2)O(n^2)O(n​2​​) O(n2)O(n^2)O(n​2​​) O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 不稳定 堆排序 O(nlog2n)O(nlog_2n)O(nlog​2​​n) O(nlog2n)O(nlog_2n)O(nlog​2​​n) O(nlog2n)O(nlog_2n)O(nlog​2​​n) O(1)O(1)O(1) 不稳定 归并排序 O(nlog2n)O(nlog_2n)O(nlog​2​​n) O(n)O(n)O(n) 稳定 基数排序 O(d(r+n))O(d(r+n))O(d(r+n)) O(r)O(r)O(r) 稳定 1 直接插入排序（Insertion Sort） 插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 优化：先用折半查找找到应该插入的位置，再移动元素。 2 希尔排序（Shell Sort） 先将待排序表分割成若干形如L[i,i+d,i+2d,...,i+kd]L[i,i+d,i+2d,...,i+kd]L[i,i+d,i+2d,...,i+kd]的特殊子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。（希尔本人建议：d初始值为n，然后每次将增量缩小一半） 适用性：仅适用于顺序表，不适用于链表 3 冒泡排序（Bubble Sort） 冒泡排序是一种交换排序，它的思路就是在待排序的数据中，两两比较相邻元素的大小，看是否满足大小顺序的要求，如果满足则不动，如果不满足则让它们互换。然后继续与下一个相邻元素的比较，一直到一次遍历完成。一次遍历的过程就被成为一次冒泡，一次冒泡的结束至少会让一个元素移动到了正确的位置。所以要想让所有元素都排序好，一次冒泡还不行，我们得重复N次去冒泡，这样最终就完成了N个数据的排序过程。 对一个长度为 nnn 的排列 p[i]p[i]p[i] 进行一轮冒泡排序的伪代码如下： 123for i = 1 to n-1: if p[i] &gt; p[i + 1]: swap(p[i], p[i + 1]) 4 快速排序（Quck Sort） 快速排序是一种交换排序，它的思路：在待排序表L[1...n]L[1...n]L[1...n]中任取一个元素 pivot 作为枢轴（或基准，通常取首元素），通过一趟排序表划分为独立的两部分L[1...k−1]L[1...k-1]L[1...k−1]和L[k+1...n]L[k+1...n]L[k+1...n]，使得L[1...k−1]L[1...k-1]L[1...k−1]中的所有元素小于 pivot，L[k+1...n]L[k+1...n]L[k+1...n]中的所有元素大于等于 pivot，则 pivot放在了其最终位置L[k]L[k]L[k]上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。 若每一次选中的“枢轴”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高。 优化： 选头、中、尾、三个位置的元素，取中间值作为枢轴元素； 随机选一个元素作为枢轴元素。 5 简单选择排序（Selection Sort） 选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。 适用性：既可以用于顺序表，也可用于链表 6 堆排序（Heap Sort） 堆排序是选择排序的一种，思路：每一趟将堆顶元素加入到有序子序列（与待排序序列中的最后一个元素交换），并将待排序元素序列再次调整为大根堆（小元素不断下坠） 什么是堆？ 若nnn个关键字序列L[1..n]L[1..n]L[1..n]满足下面某一条性质，则称为堆（Heap）： 若满足：L(i)≥L(2i)且L(i)≥L(2i+1)，(1≤i≤n/2)(1 \\leq i \\leq n / 2)(1≤i≤n/2)——大根堆（大顶堆） 若满足：L(i)≤L(2i)且L(i)≤L(2i+1)，(1≤i≤n/2)(1 \\leq i \\leq n / 2)(1≤i≤n/2)——小根堆（小顶堆） 建立大根堆： 把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足则进行调整 检查当前结点是否满足根节点&gt;=左、右，若不满足，将当前结点与更大的一个孩子互换 若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”） 建堆O(n)O(n)O(n)，排序O(nlogn)O(nlogn)O(nlogn) 在堆中插入新元素： 对于大根堆，新元素放到表尾，与父结点相比，若新元素比父节点更大，则将二者互换。新元素就这样一路上升，直到无法继续上升。 在堆中删除元素： 被删除元素用堆底元素代替，然后让该元素不断下坠，直到无法下坠为止。 7 归并排序（Merge Sort） 把两个或多个已经有序的序列合并成一个。 核心操作：把数组内的两个有序序列归并为一个。 8 基数排序（Radix Sort） 假设长度为nnn的线性表中每个结点aaa的关键字由ddd元组(kjd−1,kjd−2,kjd−3,…,kj1,kj0)\\left(k_{j}^{d-1}, k_{j}^{d-2}, k_{j}^{d-3}, \\ldots, k_{j}^{1}, k_{j}^{0}\\right)(k​j​d−1​​,k​j​d−2​​,k​j​d−3​​,…,k​j​1​​,k​j​0​​)组成，其中，0≤kji≤r−1(0≤j&lt;n,0≤i≤d−1)0 \\leq k_{j}^{i} \\leq r-1 \\quad(0 \\leq j&lt;n, 0 \\leq i \\leq d-1)0≤k​j​i​​≤r−1(0≤j&lt;n,0≤i≤d−1)，rrr称为基数。 基数排序得到递减序列的过程如下： 初始化：设置rrr个空队列，Q_{r-1}，Q_{r-2}...Q_0 按照各个关键字位权重递增的次序（个、十、百），对ddd个关键字位分别做“分配”和“收集” 分配：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入QxQ_xQ​x​​队尾 收集：把Q_{r-1}，Q_{r-2}...Q_0各个队列中的结点依次出队并链接 注意： 基数排序不是基于比较的排序算法；基数排序通常基于链式存储实现。 需要rrr个辅助队列，空间复杂度为O(r)O(r)O(r)，其中rrr为基数； 一趟分配O(n)O(n)O(n)，一趟收集O(r)O(r)O(r)，总共ddd趟分配、收集，总的时间复杂度=O(d(n+r))O(d(n+r))O(d(n+r)) 基数排序擅长解决的问题： 数据元素的关键字可以方便地拆分成ddd组，且ddd较小； 每组的关键字的取值范围不大，即rrr较小 数据元素个数nnn较大 9 外部排序 外部排序原理： 外部排序：数据元素太多，无法一次全部读入内存进行排序。 使用归并排序的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序。 步骤： 构造初始归并段：归并排序要求各个子序列有序，每次读入两个块的内容，进行内部排序后写回磁盘； 第一趟归并：将两个归并段归并为一个，缓冲区1/2空了就要立即用归并段1/2的下一块补上 第二趟归并：与第一趟类似… 时间开销分析： 外部排序时间开销=读写外存时间+内部排序所需时间+内部归并所需时间 优化： 多路归并：采用多路归并可以减少归并趟数，从而减少磁盘I/O(读写)次数 减少初始归并段数量：生成初始归并段的“内存工作区”越大，初始归并段越长，则可减少初始归并段数量r 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5; int arr[maxn] = &#123;0, 53, 17, 78, 9, 45, 65, 87, 32&#125;;//下标从1开始 int n;//数组长度 //直接插入排序void insert_sort() &#123; int i, j, tmp; for (i = 2; i &lt;= n; i++) &#123; tmp = arr[i]; for (j = i - 1; j &gt;= 1; j--) &#123; if (arr[j] &gt; tmp) &#123; arr[j + 1] = arr[j]; &#125; else &#123; break; &#125; &#125; arr[j + 1] = tmp; &#125;&#125; //希尔排序void shell_sort() &#123; int i, j, tmp, d; for (d = n / 2; d &gt;= 1; d /= 2) &#123;//增量 for (i = 1 + d; i &lt;= n; i++) &#123; tmp = arr[i]; for (j = i - d; j &gt;= d; j -= d) &#123; if (arr[j] &gt; tmp) &#123; arr[j + d] = arr[j]; &#125; else &#123; break; &#125; &#125; arr[j + d] = tmp; &#125; &#125; &#125; //冒泡排序 void bubble_sort() &#123; for (int i = 1; i &lt;= n - 1; i++) &#123; bool flag = false; for (int j = 1; j &lt;= n - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr[j], arr[j + 1]); flag = true; &#125; &#125; if (flag == false) &#123;//无交换，表已经有序 break; &#125; &#125;&#125; //快速排序——用arr[low]将子表划分int partition(int low, int high) &#123; int pivot = arr[low];//第一个元素作为枢轴元素 while (low &lt; high) &#123;//用low、high搜索枢轴的最终位置 while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123; high--; &#125; arr[low] = arr[high];//比枢轴小的元素移动到左边 while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123; low++; &#125; arr[high] = arr[low];//比枢轴大的元素移动到左边 &#125; arr[low] = pivot;//枢轴元素存放的最终位置 return low;//返回存放枢轴的最终位置 &#125; //快速排序void quck_sort(int low, int high) &#123; if (low &lt; high) &#123; int pivot_pos = partition(low, high); quck_sort(low, pivot_pos - 1); quck_sort(pivot_pos + 1, high); &#125; &#125; //简单选择排序void select_sort() &#123; for (int i = 1; i &lt;= n - 1; i++) &#123;//进行n-1趟 int mini = i;//记录最小元素位置 for (int j = i + 1; j &lt;= n; j++) &#123;//在arr[i+1...n]中选择最小元素 if (arr[j] &lt; arr[mini]) &#123; mini = j; &#125; &#125; if (mini != i) &#123; swap(arr[i], arr[mini]); &#125; &#125;&#125; //堆排序——将以 k 为根的子树调整为大根堆void heap_adjust(int k, int len) &#123; arr[0] = arr[k];//arr[0]暂存子树的根节点 for (int i = 2 * k; i &lt;= len; i *= 2) &#123;//沿key较大的子节点向下筛选 if (i &lt; len &amp;&amp; arr[i] &lt; arr[i + 1]) &#123;//比较左右孩子结点大小 i++;//取key较大的子节点下标 &#125; if (arr[0] &gt;= arr[i]) &#123;//筛选结束 break; &#125; else &#123; arr[k] = arr[i];//将arr[i]调整到双亲结点上 k = i;//修改k，以便继续向下筛选 &#125; &#125; arr[k] = arr[0];//被筛选节点的值放入最终位置 &#125; //堆排序——建立大根堆void build_max_heap(int len) &#123; for (int i = len / 2; i &gt; 0; i--) &#123;//从后往前调整非终端结点 heap_adjust(i, len); &#125;&#125; //堆排序void heap_sort() &#123; build_max_heap(n); for (int i = n; i &gt; 1; i--) &#123; swap(arr[i], arr[1]); heap_adjust(1, i - 1); &#125;&#125; int *b = (int *)malloc(n * sizeof(int));//辅助数组 //归并排序——arr[low...mid]与arr[mid+1...high]各自有序，将两者合并void merge(int low, int mid, int high) &#123; int i, j, k; for (k = low; k &lt;= high; k++) &#123;//将arr中所有元素复制到b b[k] = arr[k]; &#125; //合并 for (i = low, j = mid + 1, k = low; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123; if (b[i] &lt; b[j]) &#123; arr[k] = b[i++]; &#125; else &#123; arr[k] = b[j++]; &#125; &#125; //没有归并完的部分复制到尾部 while (i &lt;= mid) arr[k++] = b[i++]; while (j &lt;= high) arr[k++] = b[j++]; &#125; //归并排序void merge_sort(int low, int high) &#123; if (low &lt; high) &#123; int mid = (low + high) / 2;//从中间拆开 merge_sort(low, mid);//对左半部分归并排序 merge_sort(mid + 1, high);//对右半部分归并排序 merge(low, mid, high);//归并 &#125;&#125; int main() &#123;// cin&gt;&gt; n; n = 8; merge_sort(1, n); for (int i = 1; i &lt;= n; i++) &#123; cout&lt;&lt; arr[i]&lt;&lt; \" \"; &#125; return 0;&#125; 练习","categories":[{"name":"03-排序","slug":"03-排序","permalink":"https://dragonliu2021.github.io/categories/03-排序/"}],"tags":[]},{"title":"哈希表","slug":"哈希表","date":"2022-04-19T05:11:17.000Z","updated":"2022-04-19T05:15:05.581Z","comments":true,"path":"2022/04/19/哈希表/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/哈希表/","excerpt":"","text":"哈希表 散列表（Hash Table），又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关，通过“散列函数（哈希函数）”：Addr=H(key)Addr=H(key)Addr=H(key)。 若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词” 通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突” 常见的散列函数 除留余数法——H(key)=key%pH(key)=key\\%pH(key)=key%p，散列表表长为mmm，取一个不大于mmm但最接近或等于mmm的质数ppp 直接定址法——H(key)=keyH(key)=keyH(key)=key 或H(key)=a∗key+bH(key)=a*key +bH(key)=a∗key+b，其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。 数字分析法——选取数码分布较为均匀的若干位作为散列地址，如手机号码。 平方取中法——取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。如身份证号。 解决冲突 拉链法：把所有“同义词”存储在一个链表中，Java中的HashMap、HashSet 开放定址法：可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：Hi=(H(key)+di)%mH_{i}=\\left(H(k e y)+d_{i}\\right) \\% mH​i​​=(H(key)+d​i​​)%m，i=0,1,2,…,k(k⩽m−1)i=0,1,2, \\ldots, k \\quad(k \\leqslant m-1)i=0,1,2,…,k(k⩽m−1)，其中mmm表示散列表表长；did_id​i​​为增量序列；iii可理解为“第iii次发生冲突” 线性探测法：di=0,1,2,3,…,m−1d_{i}=0,1,2,3, \\ldots, m-1d​i​​=0,1,2,3,…,m−1; 即发生冲突时，每次往后探测相邻的下一个单元是否为空 线性探测法很容易造成同义词、非同义词的“聚集（堆积）”现象，严重影响查找效率 产生原因——冲突后再探测一定是放在某个连续的位置 平方探测法：当 di=02,12,−12,22,−22,…,k2,−k2\\mathrm{d}_{\\mathrm{i}}=\\mathbf{0}^{2}, \\mathbf{1}^{2},-\\mathbf{1}^{2}, \\mathbf{2}^{2},-\\mathbf{2}^{2}, \\ldots, \\mathbf{k}^{2},-\\mathbf{k}^{2}d​i​​=0​2​​,1​2​​,−1​2​​,2​2​​,−2​2​​,…,k​2​​,−k​2​​ 时，称为平方探测法，又称二次探测法其中 k≤m/2\\mathbf{k} \\leq \\mathbf{m} / \\mathbf{2}k≤m/2 比起线性探测法更不易产生“聚集（堆积）”问题 散列表长度m必须是一个可以表示成4j+34j+34j+3的素数，才能探测到所有位置 伪随机序列法：di\\mathbf{d}_{\\mathrm{i}}d​i​​ 是一个伪随机序列，如 di=0,5,24,11,…\\mathrm{d}_{\\mathrm{i}}=\\mathbf{0 , 5 , 2 4 , 1 1 , \\ldots}d​i​​=0,5,24,11,… 再散列法：除了原始的散列函数H(key)H(key)H(key)之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：Hi=RHi(Key)i=1,2,3….,k\\mathrm{H}_{\\mathrm{i}}=\\mathrm{RH}_{\\mathrm{i}}(\\mathrm{Key}) \\quad \\mathrm{i}=1,2,3 \\ldots ., \\mathrm{k}H​i​​=RH​i​​(Key)i=1,2,3….,k STL 无序集合：unordered_set 无序字典：unordered_map 练习 洛谷——P4305 [JLOI2011]不重复数字：需要加快读 leetcode-1 两数之和 (简单)","categories":[{"name":"02-数据结构","slug":"02-数据结构","permalink":"https://dragonliu2021.github.io/categories/02-数据结构/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"https://dragonliu2021.github.io/tags/哈希表/"}]},{"title":"并查集","slug":"并查集","date":"2022-04-19T05:11:04.000Z","updated":"2022-04-19T05:14:26.806Z","comments":true,"path":"2022/04/19/并查集/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/并查集/","excerpt":"","text":"简介 英文：Disjoint Set，即“不相交集合”。将编号分别为1…N的N个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合。常见两种操作： 合并两个集合； 查找某元素属于哪个集合。 代码 1 无优化 123456789101112131415161718192021222324252627const int maxn = 1e5;int node[maxn];//每个节点的父节点//初始化void init(int n) &#123; for( int i=0; i&lt;=n; i++ )&#123; node[i] = i; &#125;&#125;//查找当前元素所在树的根节点(代表元素)int find(int x) &#123; if (x == node[x]) return x; return find(node[x]);&#125;//合并x和y所在的集合void merge(int x, int y) &#123; int root_x = find(x);//找到根节点 int root_y = find(y); if (root_x == root_y)//两者根节点相同 return ; node[root_x] = root_y;//将x的根节点与y的根节点相连&#125;//判断xy是否属于一个集合bool same(int x, int y) &#123; return find(x) == find(y);&#125; 2 优化(路径压缩+按秩合并) 1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 1e5;int node[maxn];//每个节点的父节点int Rank[maxn];//树的高度//初始化void init(int n) &#123; for (int i=0; i&lt;=n; i++) &#123; node[i] = i; Rank[i] = 1; &#125;&#125;//路径压缩//查找当前元素所在树的根节点(代表元素)int find(int x) &#123; if (x == node[x]) return x; return node[x] = find(node[x]);//在第一次查找时，将节点直连到根节点&#125;//按秩合并//合并x和y所在的集合void merge(int x, int y) &#123; int root_x = find(x);//找到根节点 int root_y = find(y); if (root_x == root_y)//两者根节点相同 return ; //判断两棵树的高度，然后在决定谁为子树 if (Rank[root_x] &lt; Rank[root_y]) node[root_x] = root_y;//将x的根节点接到y的根节点下 else &#123; node[root_y] = root_x;//将y的根节点与x的根节点下 if (Rank[root_x] == Rank[root_y])//树的高度相同 Rank[root_x]++;//root_x树高度+1 &#125;&#125;//判断xy是否属于一个集合bool same(int x, int y) &#123; return find(x) == find(y);&#125; 时间复杂度 直接实现的话，时间复杂度最坏可以到O(n)。 两个常见优化，启发式合并，路径压缩。 启发式合并：把大小较小的集合挂在较大的集合上。（有的写法是考虑深度而不是大小） 路径压缩：询问过的点到根节点的路径，都直接挂在根节点上。 实现其中任意一个时间复杂度变为O(\\log n)。 实现其中两个，时间复杂度变为O(\\alpha(n))，其中\\alpha(n)是阿克曼函数的反函数，可以认为非常小。 多数情况下为了简单，都实现路径压缩（只需要一句赋值）而不实现启发式合并（需要记录大小） 在某些题目中由于会爆栈，需要使用非递归的find函数。 练习 洛谷——P3367 【模板】并查集","categories":[{"name":"02-数据结构","slug":"02-数据结构","permalink":"https://dragonliu2021.github.io/categories/02-数据结构/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://dragonliu2021.github.io/tags/并查集/"}]},{"title":"STL","slug":"STL","date":"2022-04-19T05:10:40.000Z","updated":"2022-04-19T05:13:22.235Z","comments":true,"path":"2022/04/19/STL/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/STL/","excerpt":"","text":"1 vector(向量) vector是与数组相关的序列式容器，set模版类的定义在头文件&lt;vector&gt;中。当我们在程序中需要使用动态数组时， vector将会是理想的选择， vector可以在使用过程中动态地增长存储空间。 1234567891011121314151617181920212223242526272829303132333435363738394041// 定义及初始化vector&lt;int&gt; s;// 定义⼀个空的vector对象，存储的是int类型的元素vector&lt;int&gt; s(n, 1);// 定义⼀个含有n个int元素(1)的vector对象vector&lt;int&gt; s(first, last);// 从由迭代器first和last定义的序列[first, last)中复制初值初始化vector&lt;int&gt; s = &#123;1,7,3,6,5,6&#125;;// 基本操作s[i] // 直接以下标⽅式访问容器中的元素，编号从0开始s.front() // 返回⾸元素s.back() // 返回尾元素s.push_back(x) // 向表尾插⼊元素xs.pop_back() // 删除表尾元素s.size() // 返回表⻓s.empty() // 表为空时，返回真，否则返回假s.begin() // 返回指向⾸元素的随机存取迭代器s.end() // 返回指向尾元素的下⼀个位置的随机存取迭代器// 插入s.insert(it, val); // 向迭代器it指向的元素前插⼊新元素vals.insert(s.begin()+pos, val);s.insert(it, n, val); // 向迭代器it指向的元素前插⼊n个新元素vals.insert(it, first, last);// 向迭代器it指向的元素前插⼊迭代器first和last所指定的序列[first, last)s.erase(it) // 删除由迭代器it所指向的元素s.erase(first, last) // 删除由迭代器first和last所指定的序列[first, last)s.reserve(n) // 预分配缓冲空间，使存储空间至少可容纳n个元素s.resize(n) // 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素默认值填满s.resize(n, val) // 改变序列长度，超出的元素将会全部被删除，需要扩展(原空间小于n)的用元素val填满s.clear() // 删除容器中的所有元素。resize和clear是对表的有效元素进行的操作，但不⼀定改变缓冲空间的⼤小s.swap(v) // 将s与另⼀个vector对象进行交换s.assign(first, last)// 将序列替换成由迭代器指示的[first, last)，不能是原序列中的⼀部分operator: &gt; &lt; &gt;= &lt;= == != //按照字典序⽐较两个序列 // 组合操作s.insert(s.begin(), x) // 向表头插⼊元素xs.erase(s.begin()) // 删除表头元素reverse(s.begin(), s.end()) // 反转向量sort(s.begin(), s.end()); // 排序 // 函数返回一个vectorreturn vector&lt;int&gt; &#123;a, b&#125;; 2 pair(二元组) pair用来表示一个二元组或元素对，定义在头文件&lt;utility&gt;中。pair模版类需要两个参数：首元素的数据类型和尾元素的数据类型。 pair模版类对象有两个成员： first和second，分别表示首元素和尾元素。 123456// 定义pair&lt;double, double&gt; p;p = make_pair(int, int);// 基本操作operator: &lt; &gt; &lt;= &gt;= == != // 其规则是先⽐较first， first相等时再比较second，这符合⼤多数应⽤的逻辑 3 set(集合) set是与集合相关的关联式容器，set模版类的定义在头文件&lt;set&gt;中。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序(默认升序)。set中元素的值不能直接被改变。 标准库提供set关联容器分为： 按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set)； 无序集合：unordered_set(用哈希函数组织的set)；unordered_multiset(哈希组织的set，关键字可以重复出现)。 123456789101112131415161718192021222324252627282930313233343536373839// 定义set&lt;T&gt; s;set&lt;T&gt;::iterator it;//迭代器int arr[]=&#123;0,1,2,3&#125;;set&lt;int&gt; ss(arr, arr+4);//数组初始化set&lt;int&gt; ss(s);//集合初始化// 基本操作s.begin() // 返回指向第⼀个元素的迭代器，如果set为空则返回的迭代器不能解引用s.clear() // 清除所有元素s.count(T) // 返回某个元素的个数，多重集合也是返回个数s.empty() // 如果集合为空，返回true(真）s.end() // 返回指向最后⼀个元素之后的迭代器，不是最后⼀个元素s.equal_range(T) // 返回集合中与给定值相等的上下限的两个迭代器(pair)s.erase(T) // 删除迭代器指定位置的元素或与对象匹配的元素s.find(T) // 返回⼀个指向被查找到元素的迭代器s.get_allocator() // 返回集合的分配器s.insert(T) // 在集合中插⼊元素s.lower_bound(T) // 返回指向⼤于（或等于）某值的第⼀个元素的迭代器s.key_comp() // 返回⼀个⽤于元素间值⽐较的函数，默认operator&lt;s.max_size() // 返回集合能容纳的元素的最⼤限值s.rbegin() // 返回指向集合中最后⼀个元素的反向迭代器s.rend() // 返回指向集合中第⼀个元素的反向迭代器s.size() // 集合中元素的数⽬s.swap(set&lt;T&gt;) // 交换两个集合变量s.upper_bound(T) // 返回⼤于某个值元素的迭代器s.value_comp() // 返回⼀个⽤于⽐较元素间的值的函数//遍历输出for (auto ptr = s.begin(); ptr != s.end(); ptr++) &#123; cout&lt;&lt; *ptr&lt;&lt; \" \";&#125;// 修改排序struct cmp &#123; bool operator () (const int&amp; u, const int&amp; v) const &#123; if (abs(u - v) &lt;= k) return false; return u &lt; v; &#125;&#125;;set&lt;int, cmp&gt; se; 4 string(字符串) string类的定义在头文件&lt;string&gt;&lt;string&gt;&lt;string&gt;中。string类其实可以看作是一个字符的vector， vector上的各种操作都可以适用于string，另外，string类对象还支持字符串的拼合、转换等操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 定义string str;// 基本操作operator + // 拼合//string转char指针char *p=(char*)str.c_str();char*p=(char*)str.data();// 关于输入cin&gt;&gt; str;//接受空、回车格结尾的字符串cin.ignore();//配合使用，清除以回车结束的输入缓冲区的内容 getline(cin, str);//读取一行//字串型的串流，用于按空格间隔的字串分割stringstream ss;ss&lt;&lt; str;//输入str到ss(屏幕)，看方向ss&gt;&gt; str;//ss(屏幕)输入到str//@brief: 指定单个分隔符（单个字符或子串）分割字符串//@param: src 原字符串；delimiter 分隔符，单个字符或子串vector&lt;string&gt; splitStr(const string&amp; src, const string&amp; delimiter) &#123; vector&lt;string&gt; vetStr; // 入参检查 // 1.原字符串为空或等于分隔符，返回空 vector if (src == \"\" || src == delimiter) &#123; return vetStr; &#125; // 2.分隔符为空返回单个元素为原字符串的 vector if (delimiter == \"\") &#123; vetStr.push_back(src); return vetStr; &#125; string::size_type startPos = 0; auto index = src.find(delimiter); while (index != string::npos) &#123; auto str = src.substr(startPos, index - startPos); if (str != \"\") &#123; vetStr.push_back(str); &#125; startPos = index + delimiter.length(); index = src.find(delimiter, startPos); &#125; // 取最后一个子串 auto str = src.substr(startPos); if (str != \"\") &#123; vetStr.push_back(str); &#125; return vetStr;&#125;//char字符处理isalpha(ch);//字母（不区分大小写）isupper(ch);//大写字母islower();//小写字母isdigit();//数字isalnum();//字母或数字toupper();//转大写tolower();//转小写//string转int等类型int stoi (const string&amp; str, size_t* idx = 0, int base = 10);//*idx是指向size_t类型对象的指针，其值由函数设置为数值后str中下一个字符的位置；base是指str的基数，默认十进制long stol (const string&amp; str, size_t* idx = 0, int base = 10);unsigned long stoul (const string&amp; str, size_t* idx = 0, int base = 10);long long stoll (const string&amp; str, size_t* idx = 0, int base = 10);unsigned long long stoull (const string&amp; str, size_t* idx = 0, int base = 10);float stof (const string&amp; str, size_t* idx = 0);double stod (const string&amp; str, size_t* idx = 0);long double stold (const string&amp; str, size_t* idx = 0);//int等类型转stringstring to_string (T);//find函数str.find(tmp_str);//返回下标位置，没有则返回str.nposstr.find_first_of(tmp_str);//第一次出现的位置str.find_last_of(tmp_str);//最后一次出现的位置str.find(tmp_str, pos);//从下标pos开始查找str.rfind(tmp_str);//反向查找，与正向查找结合确定子串的唯一性//取子串string substr (size_t pos = 0, size_t len = npos) const;//在字符位置pos开始，跨越len个字符（或直到字符串的结尾，以先到者为准）对象的部分//字符串大小写转化transform(s.begin(),s.end(),s.begin(),::tolower);transform(s.begin(),s.end(),s.begin(),::toupper); 5 list(列表) list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为O(n)O(n)O(n)；但由于链表的特点，能高效地进行插入和删除。 使用： 需要高效的随机存取，而不在乎插入和删除的效率，使用vector; 如果需要大量的插入和删除，而不关心随机存取，则应使用list 1234567891011121314151617181920212223// 定义list&lt;int&gt; l;//声明一个空列表list&lt;int&gt; l(n);//声明一个有n个元素的列表，每个元素都是由其默认构造函数T()构造出来的list&lt;int&gt; l(n,val);//声明一个由n个元素的列表，每个元素都是由其复制构造函数T(val)得来的list&lt;int&gt; l();//声明一个空列表list&lt;int&gt; l(first,last);//声明一个列表，其元素的初始值由区间所指定的序列中的元素;// 基本操作l.begin() // 得到一个指向容器起始位置的iteratorl.end() //返回list末端下一位置，如a[n]中的第n+1个位置a[n]，实际是不存在，经常作为循环结束判断条件使用l.push_back(x) //list的末端插入xl.push_front(x) // 从list的头部插入xl.empty() // 利用empty() 判断list是否为空，空返回truel.resize(n) //将l的长度改为n，超出的元素将被删除，如果需要扩展那么调用默认构造函数T()将元素加到list末端l.resize(n, val)//扩展元素要调用构造函数T(val)函数进行元素构造，其余部分与resize相同l.clear() //清空list中的所有元素l.front() //获得list容器中的头部元素l.back() //可以获得list容器的最后一个元素l.pop_back // 删除最后一个元素l.pop_front() // 删除第一个元素；序列必须不为空，当list为空时调用pop_back和pop_front会使程序崩掉l.assign() //具体和vector中的操作类似l.swap(ll) //交换两个链表，swap(l ,ll)也可merge() //合并两个链表并使之默认升序(也可改)，l1.merge(l2，greater&lt;int&gt;()); 调用结束后l2变为空，l1中元素包含原来l1 和 l2中的元素，并且排好序，升序。其实默认是升序，greater&lt;int&gt;()可以省略，另外greater&lt;int&gt;()是可以变的，也可以不按升序排列。 6 stack(栈) stack模版类的定义在&lt;stack&gt;头文件中，stack模版类需要两个模版参数，一个是元素类型，另一个是容器类型，但是只有元素类型是必要的，在不指定容器类型时，默认容器的类型为deque。 123456789// 定义stack&lt;int&gt; s;// 基本操作s.push(x); // ⼊栈s.pop(); // 出栈，不返回值x = s.top(); // 访问栈顶，s.empty(); // 当栈空时，返回trues.size(); // 访问栈中元素个数 7 queue(队列) queue模版类的定义在头文件&lt;queue&gt;中。queue与stack相似， queue模版类也需要两个模版参数，一个元素类型，一个容器类型，元素类型是必须的，容器类型是可选的。 标准库提供queue分为： queue(队列)：queue从队首弹出，先入先出，并且queue只能从队首删除元素，但是两端都能访问。 deque(双向队列)：可以访问两端并且可以在队首和队尾删除和插入元素 priority_queue(优先队列)：优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权出队列（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）；priority_queue模版类有三个模版参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。其中后两者都可以忽略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队列时列尾元素先出队）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 队列定义queue&lt;int&gt; q;// 队列基本操作q.push(x); // 从队尾⼊队列q.pop(); // 从队首出队列q.front(); // 访问队首元素q.back(); // 访问队尾元素q.empty(); // 如果队列为空，则返回true，否则返回falseq.size(); // 访问队列中的元素个数// 双向队列定义deque&lt;int&gt; dq; //创建一个int双端队列dq// 双向队列基本操作dq.empty(); //判断队列是否为空，为空返回truedq.push_front(s); //将s从队头入队dq.push_back(s); //将s从队尾入队，和普通队列方式一样dq.front(); //只返回队头元素dq.back(); //只返回队尾元素dq.pop_front(); //将队头元素弹出dq.pop_back(); //将队尾元素弹出dq.clear(); //将队列清空//组合操作//C++中的queue自身是不支持clear操作的，但是双端队列deque是支持clear操作的。queue&lt;int&gt; empty;swap(empty, q);// 优先队列定义priority_queue&lt;int&gt; q;priority_queue&lt;pair&lt;int, int&gt; &gt; qq; // 注意在两个尖括号之间⼀定要留空格，防止误判priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; qqq; // 定义小的先出队列// 优先队列基本操作q.empty() // 如果队列为空，则返回true，否则返回falseq.size() // 返回队列中元素的个数q.pop() // 删除队首元素，但不返回其值q.top() // 返回具有最高优先级的元素值，但不删除该元素q.push(x) // 在基于优先级的适当位置插⼊新元素x // 算子实现class T&#123; public: int x, y, z; T(int a, int b, int c) : x(a), y(b), z(c) &#123;&#125;&#125;;bool operator &lt; (const T &amp;tOne, const T &amp;tTwo)&#123; return tOne.z &lt; tTwo.z; // 按照z的顺序来决定tOne和tTwo的顺序&#125;int main()&#123; priority_queue&lt;T&gt; q; q.push(T(4, 4, 3)); q.push(T(2, 2, 5)); q.push(T(1, 5, 4)); q.push(T(3, 3, 6)); while (!q.empty())&#123; T t = q.top(); q.pop(); cout &lt;&lt; t.x &lt;&lt; \" \" &lt;&lt; t.y &lt;&lt; \" \" &lt;&lt; t.z &lt;&lt; '\\n'; &#125; return 0;&#125; 8 map(字典) map是与字典相关的关联式容器，map模版类的定义在头文件&lt;map&gt;&lt;map&gt;&lt;map&gt;中，用有序二叉树表存储类型为pair&lt;const Key, T&gt;的元素对序列。 序列中的元素以const Key部分作为标识， map中所有元素的Key值必须是唯一的，multimap则允许有重复的Key值。unordered_map是无序 map 容器。 将map可以通过一个Key值来快速决定一个元素，因此非常适合于需要按照Key值查找元素的容器。map模版类需要四个模版参数，第一个是键值类型，第二个是元素类型，第三个是比较算子，第四个是分配器类型。其中键值类型和元素类型是必要的。 12345678910111213141516171819202122// 字典定义map&lt;string, int&gt; m;// 字典基本操作/* 向map中插⼊元素 */m[key] = value; // [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分,否则将会创建⼀个键值为key的元素对,值域为默认值。所以可以⽤该操作向map中插⼊元素对或修改已经存在的元素对的值域部分。m.insert(make_pair(key, value)); // 也可以直接调用insert方法插⼊元素对,insert操作会返回⼀个pair,当map中没有与key相匹配的键值时,其first是指向插⼊元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false，并且不会更新value/* 查找元素 */int i = m[key]; // key不存在时,会创建键值为key(当另⼀个元素是整型时m[key]=0)的元素对map&lt;string, int&gt;::iterator it = m.find(key); // 如果map中存在与key相匹配的键值时,find操作将返//回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参见vector中提到的begin()和end()操作)/* 删除元素 */m.erase(key); // 删除与指定key键值相匹配的元素对,并返回被删除的元素的个数m.erase(it); // 删除由迭代器it所指定的元素对,并返回指向下⼀个元素对的迭代器/* 其他操作 */m.size(); // 返回元素个数m.empty(); // 判断是否为空，空返回truem.clear(); // 清空所有元素size_type count (const key_type&amp; k) const;//按key搜索 9 bitset() bitset模版类的定义在&lt;bitset&gt;头文件中，用来方便地管理一系列的bit位类。 bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计。bitset模板类需要一个模版参数，用来明确指定含有多少位。 12345678910111213141516171819202122232425// 定义const int MAXN = 32;bitset&lt;MAXN&gt; bt; // bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0bitset&lt;MAXN&gt; bt1(0xf); // 0xf 表示十六进制数 f，对应二进制 1111，将 bt1 低 4 位初始化为 1bitset&lt;MAXN&gt; bt2(012); // 012 表示八进制数 12，对应二进制 1010，即将 bt2 低 4 位初始化为 1010bitset&lt;MAXN&gt; bt3(\"1010\"); // 将 bt3 低 4 位初始化为 1010bitset&lt;MAXN&gt; bt4(s, pos, n); // 将 01 字符串 s 的 pos 位开始的 n 位初始化 bt4// 基本操作bt.any() // bt 中是否存在置为 1 的二进制位bt.none() // bt 中不存在置为 1 的二进制位bt.count() // bt 中置为 1 的二进制位的个数bt.size() // bt 中二进制位的个数bt[pos] // 访问 bt 中在 pos 处的二进制位bt.test(pos) // bt 中在 pos 处的二进制位是否为 1bt.set() // 把 bt 中所有二进制位都置为 1bt.set(pos) // 把 bt 中在 pos 处的二进制位置为 1bt.reset() // 把 bt 中所有二进制位都置为 0bt.reset(pos) // 把 bt 中在pos处的二进制位置为0bt.flip() // 把 bt 中所有二进制位逐位取反bt.flip(pos) // 把 bt 中在 pos 处的二进制位取反bt[pos].flip() // 同上bt.to_ulong() // ⽤用 bt 中同样的二进制位返回⼀个 unsigned long 值bt.to_string()//转字符串os &lt;&lt; bt // 把 bt 中的位集输出到 os 流 10 iterator(迭代器) iterator（迭代器）是用于访问容器中元素的指示器，从这个意义上说， iterator（迭代器）相当于数据结构中所说的“遍历指针”，也可以把iterator（迭代器）看作是一种泛化的指针。每种STL容器都有自己的iterator（迭代器）子类。 11 algorithm 1234567891011121314151617181920212223// 最大值最小值max_element(v.begin(),v.end()); //返回容器最大值的迭代器min_element(v.begin(),v.end()); //返回容器最小值的迭代器// 排序sort(v.begin(), v.end(), cmp); //cmp可以自定义，默认升序排序// 自定义cmp，使其降序bool cmp(int a, int b)&#123; return a &gt; b; &#125;// lamda表达式sort(v.begin(), v.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1];&#125;);reverse(v.begin(), v.end()); //反转容器void * memset ( void * ptr, int value, size_t num );//将ptr所指向的某一块内存中的前num个字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为指向s的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。fill(begin, last, val);//将[begin, last)赋值为valmemcpy(target, source, sizeof(int)*k);//复制source数组的前k个到targetmemcpy(target, source, sizeof(source));//复制source数组到targetlower_bound(a, a+n, x);//查找&gt;=x的第一个位置__gcd(int x, int y)//求x与y的最大公约数accumulate(vect.begin(), vect.end(), 0);//以0为累加初值累加 12 一些常量 name expresses value INT_MIN Minimum value for an object of type int -32767 (−215-2^{15}−2​15​​​+1) or less { -2147483647 (−231-2^{31}−2​31​​​+1)} INT_MAX Maximum value for an object of type int 32767 (2152^{15}2​15​​-1​) or greater {2147483647 (2312^{31}2​31​​-1)} UINT_MAX Maximum value for an object of type unsigned int 65535 (216−12^{16}-12​16​​−1) or greater {232−12^{32}-12​32​​−1} LLONG_MIN Minimum value for an object of type long long int -9223372036854775807 (−263+1-2^{63}+1−2​63​​+1) or less LLONG_MAX Maximum value for an object of type long long int 9223372036854775807 (263−12^{63}-12​63​​−1) or greater ULLONG_MAX Maximum value for an object of type unsigned long long int 18446744073709551615 (264−12^{64}-12​64​​−1) or greater 13 一些技巧 13.1 ++ 和–的小技巧 a++ 和 a 都是将 a 加 1，但是 a 返回值为 a，而 ++a 返回值为 a+1。如果只是希望增加 a 的值，而不需要返回值，则推荐使用 ++a，其运行速度会略快一些。","categories":[{"name":"02-数据结构","slug":"02-数据结构","permalink":"https://dragonliu2021.github.io/categories/02-数据结构/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://dragonliu2021.github.io/tags/STL/"}]},{"title":"基本","slug":"基本","date":"2022-04-19T05:01:51.000Z","updated":"2022-04-19T05:11:25.207Z","comments":true,"path":"2022/04/19/基本/","link":"","permalink":"https://dragonliu2021.github.io/2022/04/19/基本/","excerpt":"","text":"《数据结构（C语言版）》严蔚敏、吴伟民 编著 清华大学出版社 2017 《算法设计技巧与分析》[沙特] M.H.Alsuwaiyel 著 吴伟昶 方世昌 等译 电子工业出版社 2016 1 基本概念和术语 **数据（data）**是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 **数据元素（data element）是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。有时，一个数据元素可由若干个数据项（data item）**组成 **数据对象（data object）**是性质相同的数据元素的集合，是数据的一个子集。 **数据结构（data structure）**是相互之间存在一种或多种特定关系的数据元素的集合。 在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（structure）。 根据数据元素之间关系的不同特性，通常有下列4类基本结构： 集合：结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系； 线性结构：结构中的数据元素之间存在一个对一个的关系； 树形结构：结构中的数据元素之间存在一个对多个的关系； 图状结构或网状结构：结构中的数据元素之间存在多个对多个的关系。 数据结构的形式定义：数据结构是一个二元组Data Structure=(D，S)其中：D是数据元素的有限集，S是D上关系的有限集。 数据结构包括“逻辑结构” 和“物理结构”两个方面(层次) 结构定义中的“关系”描述的是数据元素之间的逻辑关系，因此又称为数据的逻辑结构。 数据结构在计算机中的表示（又称映像）称为数据的物理结构，又称存储结构。它包括数据元素的表示和关系的表示。 任何一个算法的设计取决于选定的逻辑结构；而算法的最终实现依赖于采用的存储结构。 数据元素之间的关系在计算机中有两种不同的表示方法：顺序映像和非顺序映像，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。 顺序映像的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 非顺序映像的特点是借助指示元素存储地址的指针（pointer）表示数据元素之间的逻辑关系 (拓展)关系的映象方法： 顺序映象（顺序存储方法）：以相对的存储位置表示后继关系 链式映象（链接存储方法）：以附加信息(指针)表示后继关系 索引存储方法：通过建立存储结点信息，以及建立附加的索引表来标识结点的地址的存储方法。 散列存储方法：由节点的关键码值决定节点的存储地址。 **数据类型(data type)**是一个值的集合和定义在这个值集上的一组操作的总称。 按“值”的不同特性，高级程序语言中的数据类型可分为两类： 非结构的原子类型：原子类型的值是不可分解的，例如C语言中的基本类型（整型、实型、字符型和枚举类型）、指针类型和空类型。 结构类型：结构类型的值是由若干成分按某种结构组成的，因此是可以分解的，并且它的成分可以是非结构的，也可以是结构的。例如数组的值由若干分量组成，每个分量可以是整数，也可以是数组等。在某种意义上，数据结构可以看成是“一组具有相同结构的值”，则结构类型可以看成由一种数据结构和定义在其上的一组操作组成。 **抽象数据类型（Abstract Data Type，简称ADT）**是指一个数学模型以及定义在该模型上的一组操作。 抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。（支持了逻辑设计和物理实现的分离，支持封装和信息隐蔽） 抽象数据类型和数据类型实质上是一个概念。例如，各个计算机都拥有的“整数”类型是一个抽象数据类型，尽管它们在不同处理器上实现的方法可以不同，但由于其定义的数学特性相同，在用户看来都是相同的。因此，“抽象”的意义在于数据类型的数学抽象特性。 若按其值的不同特性，抽象数据类型可细分为下列3种类型： **原子类型（atomic data type）**属原子类型的变量的值是不可分解的。这类抽象数据类型较少，因为一般情况下，已有的固有数据类型足以满足需求。但有时也有必要定义新的原子数据类型，例如数位为100的整数。 **固定聚合类型（fixed-aggregate data type）**属该类型的变量，其值由确定数目的成分按某种结构组成。例如，复数是由两个实数依确定的次序关系构成。 **可变聚合类型（variable-aggregate data type）**和固定聚合类型相比较，构成可变聚合类型“值”的成分的数目不确定。例如，可定义一个“有序整数序列”的抽象数据类型，其中序列的长度是可变的。 显然，后两种类型可统称为结构类型。 抽象数据类型的形式定义：三元组表示(D，S，P)其中，D是数据对象，S是D上的关系集，P是对D的基本操作集。 2 算法分析 **算法（algorithm）**是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。 算法具有5个重要特性： 有穷性：一个算法必须总是（对任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间内完成。 确定性：算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。并且，在任何条件下，算法只有惟一的一条执行路径，即对于相同的输入只能得出相同的输出。 可行性：一个算法是能行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。 输入：一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合。 输出：一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的量。 算法设计的要求： 正确性（correctness）：算法应当满足具体问题的需求。 “正确”一词的含义在通常的用法中有很大差别，大体可分为以下4个层次：a.程序不含语法错误；b.程序对于几组输入数据能够得出满足规格说明要求的结果；c.程序对于精心选择的典型、苛刻而带有刁难性的几组输入数据能够得出满足规格说明要求的结果；d.程序对于一切合法的输入数据都能产生满足规格说明要求的结果。显然，达到第d层意义下的正确是极为困难的，所有不同输入数据的数量大得惊人，逐一验证的方法是不现实的。对于大型软件需要进行专业测试，而一般情况下，通常以第c层意义的正确性作为衡量一个程序是否合格的标准。 可读性（readability）：算法主要是为了人的阅读与交流，其次才是机器执行。可读性好有助于人对算法的理解；晦涩难懂的程序易于隐藏较多错误，难以调试和修改。 健壮性（robustness）：当输入数据非法时，算法也能适当地做出反应或进行处理，而不会产生莫明其妙的输出结果。 效率与低存储量需求：通俗地说，效率指的是算法执行的时间。对于同一个问题如果有多个算法可以解决，执行时间短的算法效率高。存储量需求指算法执行过程中所需要的最大存储空间。效率与低存储量需求这两者都与问题的规模有关。求100个人的平均分与求1000个人的平均分所花的执行时间或运行空间显然有一定的差别。 算法的效率包括时间代价（时间复杂性）和空间代价（空间复杂性），两者都与问题的规模有关。 一般情况下，算法中基本操作重复执行的次数是问题规模nnn的某个函数f(n)f(n)f(n)，算法的时间量度记作T(n)=O(f(n))T(n)=O(f(n))T(n)=O(f(n))，它表示随问题规模nnn的增大，算法执行时间的增长率和f(n)f(n)f(n)的增长率相同，称做算法的渐近时间复杂度（asymptotic time complexity），简称时间复杂度。（算法中关键操作重复执行的次数是规模nnn的某个函数T(n)T(n)T(n)​） 换言之：当且仅当存在正整数ccc和n0n_0n​0​​ ，使得T(n)&lt;=c∗f(n)T(n)&lt;= c*f(n)T(n)&lt;=c∗f(n)对所有的n&gt;=n0n&gt;= n_0n&gt;=n​0​​成立，则称该算法的时间增长率在O(f(n))O(f(n))O(f(n))中，记为T(n)=O(f(n))T(n) = O(f(n))T(n)=O(f(n))​。 类似于算法的时间复杂度，以**空间复杂度（space complexity）**作为算法所需存储空间的量度，记作S(n)=O(f(n))S(n)=O(f(n))S(n)=O(f(n))​，其中n为问题的规模（或大小）。 一个上机执行的程序除了需要存储空间来寄存本身所用指令、常数、变量和输入数据外，也需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。 若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间，否则应同时考虑输入本身所需空间（和输入数据的表示形式有关）。 若额外空间相对于输入数据量来说是常数，则称此算法为原地工作；又如果所占空间量依赖于特定的输入，则除特别指明外，均按最坏情况来分析。 O符号（上界）： 一般地，说一个算法的运行时间是O(g(n))O(g(n))O(g(n))，是指如果每当输入的大小等于或超过某个阀值n0n_0n​0​​时，那么它的运行时间上限是g(n)g(n)g(n)的c倍，其中c是某个正常数。该符号的形式定义如下： 令 f(n)f(n)f(n) 和 g(n)g(n)g(n) 是从自然数集到非负实数集的两个函数, 如果存在一个自然 数 n0n_{0}n​0​​ 和一个常数 c&gt;0c&gt;0c&gt;0​, 使得 ∀n⩾n0,f(n)⩽cg(n)\\forall n \\geqslant n_{0}, f(n) \\leqslant c g(n) ∀n⩾n​0​​,f(n)⩽cg(n) 则称 f(n)f(n)f(n) 为 O(g(n))O(g(n))O(g(n)) 。 因此, 如果 limn→∞f(n)/g(n)\\lim _{n \\rightarrow \\infty} f(n) / g(n)lim​n→∞​​f(n)/g(n) 存在, 那么limn→∞f(n)g(n)≠∞\\lim _{n \\rightarrow \\infty} \\frac{f(n)}{g(n)} \\neq \\inftylim​n→∞​​​g(n)​​f(n)​​≠∞ 蕴含着 f(n)=O(g(n))f(n)=O(g(n))f(n)=O(g(n)) 非形式地，这个定义说明fff没有ggg的某个常数倍增长得快。 O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(3n)&lt;O(n!)O(1) &lt;O(log_2n) &lt; O(n) &lt; O(nlog_2n) &lt; O(n^2) &lt; O(n^3) &lt;O(2^n ) &lt; O(3^n) &lt; O(n!)O(1)&lt;O(log​2​​n)&lt;O(n)&lt;O(nlog​2​​n)&lt;O(n​2​​)&lt;O(n​3​​)&lt;O(2​n​​)&lt;O(3​n​​)&lt;O(n!)​ Ω\\OmegaΩ​ 符号（下界）： 一般而言，如果输人大小等于或大于某一阈值 n0n_{0}n​0​​, 它的运行时间下界是 g(n)g(n)g(n) 的 ccc 倍, ccc 是某个正常数, 则称算法是 Ω(g(n))\\Omega(g(n))Ω(g(n)) 。该符号的形式定义如下： 令 f(n)f(n)f(n) 和 g(n)g(n)g(n) 是从自然数集到非负实数集的两个函数, 如果存在一个自然 数 n0n_{0}n​0​​ 和一个常数 c&gt;0c&gt;0c&gt;0​, 使得 ∀n⩾n0,f(n)⩾cg(n)\\forall n \\geqslant n_{0}, f(n) \\geqslant c g(n) ∀n⩾n​0​​,f(n)⩾cg(n) 则称 f(n)f(n)f(n) 为 Ω(g(n))\\Omega(g(n))Ω(g(n)) 。 因此, 如果 limn→∞f(n)/g(n)\\lim _{n \\rightarrow \\infty} f(n) / g(n)lim​n→∞​​f(n)/g(n) 存在, 那么limn→∞f(n)g(n)≠0\\lim _{n \\rightarrow \\infty} \\frac{f(n)}{g(n)} \\neq 0lim​n→∞​​​g(n)​​f(n)​​≠0 蕴含着 f(n)=Ω(g(n))f(n)=\\Omega(g(n))f(n)=Ω(g(n)) 非正式地, 这个定义说明 fff 的增长至少和 ggg 的某个常数倍一样快。 f(n)f(n)f(n)​ 是 Ω(g(n))\\Omega(g(n))Ω(g(n))​，当且仅当 g(n)g(n)g(n)​ 是 O(f(n))O(f(n))O(f(n))​ Θ\\ThetaΘ​ 符号 ​​（精确阶）： 一般来说，对于任何大小等于或超过某一阈值 n0n_{0}n​0​​ 的输人，如果运行时间在下限 c1g(n)c_{1} g(n)c​1​​g(n) 和上限 c2g(n)c_{2} g(n)c​2​​g(n) 之间 (0&lt;c1⩽c2)\\left(0&lt;c_{1} \\leqslant c_{2}\\right)(0&lt;c​1​​⩽c​2​​), 则称算法的运行时间是 Θ(g(n))\\Theta(g(n))Θ(g(n)) 阶的。因此, 这一符号是用来表示算法的精确阶的, 它蕴含着在算法的运行时间上有确切界限。该符号的形式定义如下： 设 f(n)f(n)f(n) 和 g(n)g(n)g(n) 是从自然数集到非负实数集的两个函数, 如果存在一个自然 数 n0n_{0}n​0​​ 和两个正常数 c1c_{1}c​1​​ 和 c2c_{2}c​2​​​​​​, 使得 ∀n⩾n0,c1g(n)⩽f(n)⩽c2g(n)\\forall n \\geqslant n_{0}, c_{1} g(n) \\leqslant f(n) \\leqslant c_{2} g(n) ∀n⩾n​0​​,c​1​​g(n)⩽f(n)⩽c​2​​g(n) 则称 f(n)f(n)f(n) 是 Θ(g(n))\\Theta(g(n))Θ(g(n)) 的。 因此, 如果 limn→∞f(n)/g(n)\\lim _{n \\rightarrow \\infty} f(n) / g(n)lim​n→∞​​f(n)/g(n) 存在, 那么 \\lim _{n \\rightarrow \\infty} \\frac{f(n)}{g(n)}=c \\text { 蕴含 } f(n)=\\Theta(g(n)) 其中 ccc 必须是一个大于 0 的常数。 重要推论：f(n)=Θ(g(n))f(n)=\\Theta(g(n))f(n)=Θ(g(n)), 当且仅当 f(n)=O(g(n))f(n)=O(g(n))f(n)=O(g(n)) 并且 f(n)=Ω(g(n))f(n)=\\Omega(g(n))f(n)=Ω(g(n)) 可以认为 OOO​ 类似于⩽\\leqslant⩽​, Ω\\OmegaΩ​ 类似于⩾\\geqslant⩾, 而 Θ\\ThetaΘ 类似于 === ooo​​符号： 复杂性类 定义如下： 令 f(n)f(n)f(n) 和 g(n)g(n)g(n) 是从自然数集到非负实数集的两个函数, 如果对每一个常数 c&gt;0c&gt;0c&gt;0, 存在一个正整数 n0n_{0}n​0​​, 使得对于所有的 n⩾n0n \\geqslant n_{0}n⩾n​0​​, 都有 f(n)&lt;cg(n)f(n)&lt;c g(n)f(n)&lt;cg(n) 成立, 则称 f(n)f(n)f(n) 是 o(g(n))o(g(n))o(g(n)) 的。因此, 如果 limn→∞f(n)/g(n)\\lim _{n \\rightarrow \\infty} f(n) / g(n)lim​n→∞​​f(n)/g(n) 存在, 那么 \\lim _{n \\rightarrow \\infty} \\frac{f(n)}{g(n)}=0 \\text { 蕴含着 } f(n)=o(g(n)) 非形式地, 这个定义是说, 当 nnn 趋于无穷时, f(n)f(n)f(n) 对于 g(n)g(n)g(n) 可以忽略不计 f(n)=o(g(n))f(n)=o(g(n))f(n)=o(g(n)), 当且仅当 f(n)=O(g(n))f(n)=O(g(n))f(n)=O(g(n)), 但 g(n)≠O(f(n))g(n) \\neq O(f(n))g(n)≠O(f(n))​ 1&lt;loglogn&lt;logn&lt;n&lt;n3/4&lt;n&lt;nlogn&lt;n2&lt;2n&lt;n!&lt;2n21&lt;\\log \\log n&lt;\\log n&lt;\\sqrt{n}&lt;n^{3 / 4}&lt;n&lt;n \\log n&lt;n^{2}&lt;2^{n}&lt;n !&lt;2^{n^{2}}1&lt;loglogn&lt;logn&lt;√​n​​​&lt;n​3/4​​&lt;n&lt;nlogn&lt;n​2​​&lt;2​n​​&lt;n!&lt;2​n​2​​​​ 平摊分析：在平摊分析中，可以算出算法在整个执行过程中所用时间的平均值，称为该运算的平摊运行时间。平摊分析保证了运算的平均代价，进而也保证了算法在最坏情况下的平均开销。这与平均时间分析不同，在平均分析中，要计算同样大小的所有实例才能得到平均值，它也不像平均情况分析，不需要假设输入的概率分布。（每个元素插入1次，每个元素至多删除1次） 3 编程 枚举 模拟 4 题目列表 试题链接 解题链接 备注","categories":[{"name":"01-基本","slug":"01-基本","permalink":"https://dragonliu2021.github.io/categories/01-基本/"}],"tags":[]}],"categories":[{"name":"12-未分类","slug":"12-未分类","permalink":"https://dragonliu2021.github.io/categories/12-未分类/"},{"name":"11-技巧","slug":"11-技巧","permalink":"https://dragonliu2021.github.io/categories/11-技巧/"},{"name":"09-算法","slug":"09-算法","permalink":"https://dragonliu2021.github.io/categories/09-算法/"},{"name":"08-图论","slug":"08-图论","permalink":"https://dragonliu2021.github.io/categories/08-图论/"},{"name":"06-字符串","slug":"06-字符串","permalink":"https://dragonliu2021.github.io/categories/06-字符串/"},{"name":"05-搜索","slug":"05-搜索","permalink":"https://dragonliu2021.github.io/categories/05-搜索/"},{"name":"03-排序","slug":"03-排序","permalink":"https://dragonliu2021.github.io/categories/03-排序/"},{"name":"02-数据结构","slug":"02-数据结构","permalink":"https://dragonliu2021.github.io/categories/02-数据结构/"},{"name":"01-基本","slug":"01-基本","permalink":"https://dragonliu2021.github.io/categories/01-基本/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://dragonliu2021.github.io/tags/拓扑排序/"},{"name":"欧拉路","slug":"欧拉路","permalink":"https://dragonliu2021.github.io/tags/欧拉路/"},{"name":"关键路径","slug":"关键路径","permalink":"https://dragonliu2021.github.io/tags/关键路径/"},{"name":"KMP","slug":"KMP","permalink":"https://dragonliu2021.github.io/tags/KMP/"},{"name":"DFS","slug":"DFS","permalink":"https://dragonliu2021.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://dragonliu2021.github.io/tags/BFS/"},{"name":"回溯法","slug":"回溯法","permalink":"https://dragonliu2021.github.io/tags/回溯法/"},{"name":"二分","slug":"二分","permalink":"https://dragonliu2021.github.io/tags/二分/"},{"name":"哈希表","slug":"哈希表","permalink":"https://dragonliu2021.github.io/tags/哈希表/"},{"name":"并查集","slug":"并查集","permalink":"https://dragonliu2021.github.io/tags/并查集/"},{"name":"STL","slug":"STL","permalink":"https://dragonliu2021.github.io/tags/STL/"}]}